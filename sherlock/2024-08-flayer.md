# ∆ílayer Report
∆ílayer is a liquidity protocol for NFTs with custom Uniswap V4 hook, donate and pool integrations. This audit is to ensure the absolute security in our codebase for the ∆ílayer protocol and the Moongate bridge.

* **nSLOC**: 2278 
* **Contest details**: https://audits.sherlock.xyz/contests/468

## Disclaimer
This report contains the valid findings discovered by me (merlinboii). 

Severity Criteria: [Criteria for Issue Validity | Sherlock V2](https://docs.sherlock.xyz/audits/real-time-judging/judging)

---

## Findings

| ID | Description | Severity |
| :-: | - | :-: |
|[H-01](#h-01)| Unable to reclaim votes after collection shutdown cancellation |üçÖ|
|[H-02](#h-02)| Failure to account for delayed withdrawals in listing checks leads to incorrect listing validation and asset loss |üçÖ|
|[H-03](#h-03)| Incorrect index handling in checkpoint creation leads to incorrect initial checkpoint retrieval and potential DoS |üçÖ|
|[H-04](#h-04)| Incorrect tax accounting due to failure in handling liquidation listings in `Listings::relist()` |üçÖ|
|[H-05](#h-05)| Incorrect use of `1000` for converting basis points to decimals in `compoundedFactor_` calculation |üçÖ|
|[H-06](#h-06)| Liquidity provider loses Liquidity during collection initialization |üçÖ|
|[H-07](#h-07)| The attacker will prevent eligible users from claiming the liquidated balance |üçÖ|
|[H-08](#h-08)| Failure to delete the listing when it is reserved |üçÖ|
|[M-01](#m-01)| Inability to shutdown/sunset a newly registered collection after previous shutdown |üçã|
|[M-02](#m-02)| Refund logic in `Locker::initializeCollection()` incorrectly handles the return of unused tokens |üçã|

---

## <a name="h-01">[H-01]</a> Unable to reclaim votes after collection shutdown cancellation

* **Severity**: High
* Source: [Unable to reclaim votes after collection shutdown cancellation](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/727)

---
### Description
When a collection shutdown is canceled, the previous voter is unable to reclaim their vote due to the cancellation logic deleting the entire `_collectionParams` mapping. This results in inconsistent values and potential issues when the token returns to a shutdown state.

---
### Vulnerability Detail

The [`CollectionShutdown::cancel()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L390-L405) function deletes the `_collectionParams` mapping for a collection, which can lead to several problems:

[CollectionShutdown::cancel()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L390-L405)
```solidity
File: CollectionShutdown.sol
390:     function cancel(address _collection) public whenNotPaused {
391:         // Ensure that the vote count has reached quorum
392:         CollectionShutdownParams memory params = _collectionParams[_collection];
393:         if (!params.canExecute) revert ShutdownNotReachedQuorum();
394: 
395:         // Check if the total supply has surpassed an amount of the initial required
396:         // total supply. This would indicate that a collection has grown since the
397:         // initial shutdown was triggered and could result in an unsuspected liquidation.
398:         if (params.collectionToken.totalSupply() <= MAX_SHUTDOWN_TOKENS * 10 ** locker.collectionToken(_collection).denomination()) {
399:             revert InsufficientTotalSupplyToCancel();
400:         }
401: 
402:         // Remove our execution flag
403:         delete _collectionParams[_collection];
404:         emit CollectionShutdownCancelled(_collection);
405:     }
```

This issue can prevent users from reclaiming their votes due to an underflow error:

[CollectionShutdown::reclaimVote()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L356-L377)
```solidity
File: CollectionShutdown.sol
356:     function reclaimVote(address _collection) public whenNotPaused {
---
368:         // We delete the votes that the user has attributed to the collection
369:@>       params.shutdownVotes -= uint96(userVotes);
---
377:     }
```
Moreover, this can lead to inconsistencies in the shutdown state of collections:

Assuming:

* Before cancellation, `totalSupply` was `400` and `shutdownVotes` was `200` (allowing the collection shutdown to proceed). If the `totalSupply` then increases due to other actions, making cancellation possible, the process resets all parameters and `shutdownVotes` to zero.
* When users attempt to reclaim their votes after cancellation, they may encounter underflow errors because their previous votes are no longer tracked.
* If the collection becomes eligible for shutdown again, `shutdownVotes` will incorrectly reflect zero previous votes, resulting in some supply being locked without proper voting power accounting.

---
### Impact

Prevents users from reclaiming their votes due to underflow revert and results in inconsistencies in the shutdown state.

---
### Code Snippet

[CollectionShutdown::cancel()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L390-L405)
```solidity
File: CollectionShutdown.sol
390:     function cancel(address _collection) public whenNotPaused {
391:         // Ensure that the vote count has reached quorum
392:         CollectionShutdownParams memory params = _collectionParams[_collection];
393:         if (!params.canExecute) revert ShutdownNotReachedQuorum();
394: 
395:         // Check if the total supply has surpassed an amount of the initial required
396:         // total supply. This would indicate that a collection has grown since the
397:         // initial shutdown was triggered and could result in an unsuspected liquidation.
398:         if (params.collectionToken.totalSupply() <= MAX_SHUTDOWN_TOKENS * 10 ** locker.collectionToken(_collection).denomination()) {
399:             revert InsufficientTotalSupplyToCancel();
400:         }
401: 
402:         // Remove our execution flag
403:         delete _collectionParams[_collection];
404:         emit CollectionShutdownCancelled(_collection);
405:     }
```

[CollectionShutdown::reclaimVote()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L356-L377)
```solidity
File: CollectionShutdown.sol
356:     function reclaimVote(address _collection) public whenNotPaused {
---
368:         // We delete the votes that the user has attributed to the collection
369:@>       params.shutdownVotes -= uint96(userVotes);
---
377:     }
```

[CollectionShutdown::_collectionParams mapping](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L60-L61)
```solidity
File: CollectionShutdown.sol
60:     /// Maps a collection to it's respective shutdown parameters
61:     mapping (address _collection => CollectionShutdownParams _params) private _collectionParams;
```

[ICollectionShutdown::CollectionShutdownParams struct](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/interfaces/utils/ICollectionShutdown.sol#L43-L51)
```solidity
File: ICollectionShutdown.sol
43:     struct CollectionShutdownParams {
44:         uint96 shutdownVotes;
45:         address sweeperPool;
46:         uint88 quorumVotes;
47:         bool canExecute;
48:         ICollectionToken collectionToken;
49:         uint availableClaim;
50:         uint[] sweeperPoolTokenIds;
51:     }
```

---
### Tool used

Manual Review

---
### Recommendation

Modify the `CollectionShutdown::cancel()` function to preserve the `shutdownVotes` data. When restarting the collection shutdown process, ensure that `shutdownVotes` is not zero, which implies that this parameter is used to track **each-time** when a shutdown collection is started. 

[CollectionShutdown::start()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L135-L157)
```solidity
File: CollectionShutdown.sol
135:     function start(address _collection) public whenNotPaused {
136:         // Confirm that this collection is not prevented from being shutdown
137:         if (shutdownPrevented[_collection]) revert ShutdownPrevented();
138: 
139:         // Ensure that a shutdown process is not already actioned
140:         CollectionShutdownParams memory params = _collectionParams[_collection];
141:@>       if (params.shutdownVotes != 0) revert ShutdownProcessAlreadyStarted();
---
157:     }
```
This may necessitate additional variables or mechanisms to correctly track and handle cancellations and votes throughout the lifecycle of the shutdown process.

```diff
+ mapping(address _collection => uint96 unclaimedVote) public unclaimedVotes;
---
function cancel(address _collection) public whenNotPaused {
    // Ensure that the vote count has reached quorum
    CollectionShutdownParams memory params = _collectionParams[_collection];
    if (!params.canExecute) revert ShutdownNotReachedQuorum();

    // Check if the total supply has surpassed an amount of the initial required
    // total supply. This would indicate that a collection has grown since the
    // initial shutdown was triggered and could result in an unsuspected liquidation.
    if (params.collectionToken.totalSupply() <= MAX_SHUTDOWN_TOKENS * 10 ** locker.collectionToken(_collection).denomination()) {
        revert InsufficientTotalSupplyToCancel();
    }

+   unclaimedVotes[_collection] = params.shutdownVotes;
    // Remove our execution flag
    delete _collectionParams[_collection];
    emit CollectionShutdownCancelled(_collection);
}
```

```diff
+ mapping(address _collection => uint96 unclaimedVote) public unclaimedVotes;
---
function _vote(address _collection, CollectionShutdownParams memory params) internal returns (CollectionShutdownParams memory) {
    // Take tokens from the user and hold them in this escrow contract
    uint userVotes = params.collectionToken.balanceOf(msg.sender);
    if (userVotes == 0) revert UserHoldsNoTokens();

    // Pull our tokens in from the user
    params.collectionToken.transferFrom(msg.sender, address(this), userVotes);

    // Register the amount of votes sent as a whole, and store them against the user
    params.shutdownVotes += uint96(userVotes);
+   if (unclaimedVotes[_collection] != 0) { // Settle the unclaimed
+       params.shutdownVotes += unclaimedVotes[_collection];
+       unclaimedVotes[_collection] = 0;
+   }

    // Register the amount of votes for the collection against the user
    unchecked { shutdownVoters[_collection][msg.sender] += userVotes; }

    emit CollectionShutdownVote(_collection, msg.sender, userVotes);

    // If we can execute, then we need to fire another event
    if (!params.canExecute && params.shutdownVotes >= params.quorumVotes) {
        params.canExecute = true;
        emit CollectionShutdownQuorumReached(_collection);
    }

    return params;
}
---
function reclaimVote(address _collection) public whenNotPaused {
    // If the quorum has passed, then we can no longer reclaim as we are pending
    // an execution.
    CollectionShutdownParams storage params = _collectionParams[_collection];
    if (params.canExecute) revert ShutdownQuorumHasPassed();
+   if (params.sweeperPool != address(0)) revert ShutdownExecuted(); // prevent from reclaim after executed

    // Get the amount of votes that the user has cast for this collection
    uint userVotes = shutdownVoters[_collection][msg.sender];

    // If the user has not cast a vote, then we can revert early
    if (userVotes == 0) revert NoVotesPlacedYet();

    // We delete the votes that the user has attributed to the collection
-   params.shutdownVotes -= uint96(userVotes);
+   params.shutdownVotes != 0 ? params.shutdownVotes -= uint96(userVotes) : unclaimedVotes[_collection] -= uint96(userVotes); // Imply that if no `shutdownVotes` it is move to unclaimedVotes and not yet start again
    delete shutdownVoters[_collection][msg.sender];

    // We can now return their tokens
    params.collectionToken.transfer(msg.sender, userVotes);

    // Notify our stalkers that a vote has been reclaimed
    emit CollectionShutdownVoteReclaim(_collection, msg.sender, userVotes);
}
``` 
---

## <a name="h-02">[H-02]</a> Failure to account for delayed withdrawals in listing checks leads to incorrect listing validation and asset loss

* **Severity**: High
* Source: [Failure to account for delayed withdrawals in listing checks leads to incorrect listing validation and asset loss](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/731)

---
### Description
The [`Lockers::isListing()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L438-L452) and [`CollectionShutdown::_hasListings()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L497-L514) fail to account for listings that have been unlocked with a delayed withdrawal. As a result, the system incorrectly validates and processes listings that are no longer protected, exposing users to the risk of losing assets.

---
### Vulnerability Detail

When a protected listing is unlocked without immediate withdrawal using [`ProtectedListings::unlockProtectedListing(address _collection, uint _tokenId, bool _withdraw: FALSE)`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L287-L329), the [`canWithdrawAsset\[_collection\]\[_tokenId\]`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L321) is updated, and the listing is deleted with the listing count adjusted. 

However, the checks within [`Lockers::isListing()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L438-L452) (which checks the listing info for the specified token IDs) and [`CollectionShutdown::_hasListings()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L497-L514) (which checks the `listingCount`) do not account for this case.

As a result, when the function tries to determine if the token is still listed, it incorrectly passes, allowing the processing of a listing that is no longer protected.

Consequently, users who attempt to unlock an asset from a protected listing without triggering an immediate withdrawal risk losing their asset.

---
### Impact

This vulnerability exposes users to the risk of losing assets when attempting to unlock a protected listing without triggering an immediate withdrawal, as other processes can fulfill the listing due to incorrect checks.

The processes that use this checks are listed below:
* [Lockers::redeem()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L223)
* [Lockers::swap()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L246)
* [Lockers::swapBatch()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L277)
* [CollectionShutdown::execute()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L241)

---
### Code Snippet

[ProtectedListings::unlockProtectedListing()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L287-L329)
```solidity
File: ProtectedListings.sol
287:     function unlockProtectedListing(address _collection, uint _tokenId, bool _withdraw) public lockerNotPaused {
---
310:         // Remove our listing type
311:@>       unchecked { --listingCount[_collection]; }
312: 
313:         // Delete the listing objects
314:@>       delete _protectedListings[_collection][_tokenId];
315: 
316:         // Transfer the listing ERC721 back to the user
317:         if (_withdraw) {
318:             locker.withdrawToken(_collection, _tokenId, msg.sender);
319:             emit ListingAssetWithdraw(_collection, _tokenId);
320:         } else {
321:@>           canWithdrawAsset[_collection][_tokenId] = msg.sender;
322:         }
---
324:         // Update our checkpoint to reflect that listings have been removed
325:         _createCheckpoint(_collection);
326: 
327:         // Emit an event
328:         emit ListingUnlocked(_collection, _tokenId, fee);
329:     }
```

[Locker::isListing()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L438-L452)
```solidity
File: Locker.sol
438:     function isListing(address _collection, uint _tokenId) public view returns (bool) {
439:         IListings _listings = listings;
440: 
441:         // Check if we have a liquid or dutch listing
442:         if (_listings.listings(_collection, _tokenId).owner != address(0)) {
443:             return true;
444:         }
445: 
446:         // Check if we have a protected listing
447:         if (_listings.protectedListings().listings(_collection, _tokenId).owner != address(0)) {
448:             return true;
449:         }
450: 
451:         return false;
452:     }
```

[CollectionShutdown::_hasListings()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L497-L514)
```solidity
File: CollectionShutdown.sol
497:     function _hasListings(address _collection) internal view returns (bool) {
498:         IListings listings = locker.listings();
499:         if (address(listings) != address(0)) {
500:             if (listings.listingCount(_collection) != 0) {
501:                 return true;
502:             }
503: 
504:             // Check that no protected listings currently exist
505:             IProtectedListings protectedListings = listings.protectedListings();
506:             if (address(protectedListings) != address(0)) {
507:                 if (protectedListings.listingCount(_collection) != 0) {
508:                     return true;
509:                 }
510:             }
511:         }
512: 
513:         return false;
514:     }
```

---
### Tool used

Manual Review

---
### Recommendation

* For `Lockers::isListing()`: Update the function to include a check against the canWithdrawAsset[_collection][_tokenId] state.

```diff
function isListing(address _collection, uint _tokenId) public view returns (bool) {
    IListings _listings = listings;

    // Check if we have a liquid or dutch listing
    if (_listings.listings(_collection, _tokenId).owner != address(0)) {
        return true;
    }

    // Check if we have a protected listing
+    if (_listings.protectedListings().listings(_collection, _tokenId).owner != address(0) || _listings.protectedListings().canWithdrawAsset(_collection, _tokenId)) {
        return true;
    }

    return false;
}
```

* For `CollectionShutdown::_hasListings()`: Since this function is used in high-level execution roles (`CollectionShutdown::execute()`), a potential mitigation could involve applying a trust assumption. Specifically, avoid adding listings with pending withdrawals to the execution shutdown list to ensure that only active and protected listings are processed.
---

## <a name="h-03">[H-03]</a> Incorrect index handling in checkpoint creation leads to incorrect initial checkpoint retrieval and potential DoS

* **Severity**: High
* Source: [Incorrect index handling in checkpoint creation leads to incorrect initial checkpoint retrieval and potential DoS](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/732)

---
### Description
In the current implementation of [`ProtectedListings::_createCheckpoint()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L530-L571), when multiple listings are created for the same collection at the same timestamp, the existing checkpoint is updated, and no new checkpoint is pushed. 

However, the function incorrectly returns the wrong index for this case leads to incorrect index referencing during subsequent listing creations.

---
### Vulnerability Detail

When a checkpoint is created at the same timestamp, the existing checkpoint is updated, and no new checkpoint is pushed.

[ProtectedListings::_createCheckpoint()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L530-L571)
```solidity
File: ProtectedListings.sol
530:     function _createCheckpoint(address _collection) internal returns (uint index_) {
531:         // Determine the index that will be created
532:         index_ = collectionCheckpoints[_collection].length;
---
559:         // Get our new (current) checkpoint
560:         Checkpoint memory checkpoint = _currentCheckpoint(_collection);
561: 
562:         // If no time has passed in our new checkpoint, then we just need to update the
563:         // utilization rate of the existing checkpoint.
564:@>         if (checkpoint.timestamp == collectionCheckpoints[_collection][index_ - 1].timestamp) {
565:@>             collectionCheckpoints[_collection][index_ - 1].compoundedFactor = checkpoint.compoundedFactor;
566:@>             return index_;
567:         }
---
571:     }
```

However, the current implementation returns the wrong index for this case, causing incorrect checkpoint handling for new listing creations, especially when creating multiple listings for the same collection with different variations.

[ProtectedListings::createListings()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L117-L156)
```solidity
File: ProtectedListings.sol
116:      */
117:     function createListings(CreateListing[] calldata _createListings) public nonReentrant lockerNotPaused {
---
134:             checkpointKey = keccak256(abi.encodePacked('checkpointIndex', listing.collection));
135:             assembly { checkpointIndex := tload(checkpointKey) }
136:             if (checkpointIndex == 0) {
137:                 checkpointIndex = _createCheckpoint(listing.collection);
138:                 assembly { tstore(checkpointKey, checkpointIndex) }
139:             }
---
143:             tokensReceived = _mapListings(listing, tokensIdsLength, checkpointIndex) * 10 ** locker.collectionToken(listing.collection).denomination();
---
156:     }
```
An edge case arises when a new listing is created for a collection that has no checkpoints (`collectionCheckpoints[_collection].length == 0`). 

Assuming `erc721b` has no existing checkpoints (length = 0):
* Creating 2 `CreateListing`s for the same collection (`erc721b`) with different variants should result in only one checkpoint being created.
* In the first iteration, the [`_createCheckpoint()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L530-L571) returns `0` as the index, stores it in `checkpointIndex`, and updates the transient storage at the `checkpointKey` slot. The listing is then stored with the current checkpoint.

[ProtectedListings::createListings()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L117-L156)
```solidity
File: ProtectedListings.sol
116:      */
117:     function createListings(CreateListing[] calldata _createListings) public nonReentrant lockerNotPaused {
---
134:             checkpointKey = keccak256(abi.encodePacked('checkpointIndex', listing.collection));
135:             assembly { checkpointIndex := tload(checkpointKey) }
136:@>           if (checkpointIndex == 0) {
137:@>               checkpointIndex = _createCheckpoint(listing.collection);
138:@>               assembly { tstore(checkpointKey, checkpointIndex) }
139:             }
---
143:             tokensReceived = _mapListings(listing, tokensIdsLength, checkpointIndex) * 10 ** locker.collectionToken(listing.collection).denomination();
---
156:     }
```
* In the second iteration, since `checkpointKey` stores `0`, [`_createCheckpoint()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L530-L571) is triggered again and returns `1` (the length of checkpoints) even though no new checkpoint was pushed.

As a result, the second iteration incorrectly references index `1`, even though the checkpoint only exists at index `0` (with a length of 1). This causes incorrect indexing for the listings.

---
### Impact

Incorrect index returns lead to the wrong initial checkpoint index for new listings, causing incorrect checkpoint retrieval and utilization. This can result in inaccurate data and potential out-of-bound array access, leading to a Denial of Service (DoS) in [`ProtectedListings.unlockPrice()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L607-L617)

---
### Code Snippet

[ProtectedListings::_createCheckpoint()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L530-L571)
```solidity
File: ProtectedListings.sol
530:     function _createCheckpoint(address _collection) internal returns (uint index_) {
531:         // Determine the index that will be created
532:         index_ = collectionCheckpoints[_collection].length;
---
559:         // Get our new (current) checkpoint
560:         Checkpoint memory checkpoint = _currentCheckpoint(_collection);
561: 
562:         // If no time has passed in our new checkpoint, then we just need to update the
563:         // utilization rate of the existing checkpoint.
564:@>         if (checkpoint.timestamp == collectionCheckpoints[_collection][index_ - 1].timestamp) {
565:@>             collectionCheckpoints[_collection][index_ - 1].compoundedFactor = checkpoint.compoundedFactor;
566:@>             return index_;
567:         }
---
571:     }
```

[ProtectedListings::createListings()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L117-L156)
```solidity
File: ProtectedListings.sol
116:      */
117:     function createListings(CreateListing[] calldata _createListings) public nonReentrant lockerNotPaused {
---
134:             checkpointKey = keccak256(abi.encodePacked('checkpointIndex', listing.collection));
135:             assembly { checkpointIndex := tload(checkpointKey) }
136:@>           if (checkpointIndex == 0) {
137:@>               checkpointIndex = _createCheckpoint(listing.collection);
138:@>               assembly { tstore(checkpointKey, checkpointIndex) }
139:             }
---
143:             tokensReceived = _mapListings(listing, tokensIdsLength, checkpointIndex) * 10 ** locker.collectionToken(listing.collection).denomination();
---
156:     }
```

[ProtectedListings::unlockPrice()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/ProtectedListings.sol#L607-L617)
```solidity
File: ProtectedListings.sol
607:     function unlockPrice(address _collection, uint _tokenId) public view returns (uint unlockPrice_) {
608:         // Get the information relating to the protected listing
609:         ProtectedListing memory listing = _protectedListings[_collection][_tokenId];
610: 
611:         // Calculate the final amount using the compounded factors and principle amount
612:         unlockPrice_ = locker.taxCalculator().compound({
613:             _principle: listing.tokenTaken,
614:             _initialCheckpoint: collectionCheckpoints[_collection][listing.checkpoint],
615:             _currentCheckpoint: _currentCheckpoint(_collection)
616:         });
617:     }
```

---
### Tool used

Manual Review

---
### Recommendation

Update the return value of the `ProtectedListings::_createCheckpoint()` to return `index_ - 1` when the checkpoint is updated at the same timestamp to ensure that subsequent listings reference the correct index.

```diff
function _createCheckpoint(address _collection) internal returns (uint index_) {
    // Determine the index that will be created
    index_ = collectionCheckpoints[_collection].length;
---
    // If no time has passed in our new checkpoint, then we just need to update the
    // utilization rate of the existing checkpoint.
    if (checkpoint.timestamp == collectionCheckpoints[_collection][index_ - 1].timestamp) {
        collectionCheckpoints[_collection][index_ - 1].compoundedFactor = checkpoint.compoundedFactor;
-        return index_;
+        return (index_ - 1);
    }
---
}
```
---

## <a name="h-04">[H-04]</a> Incorrect tax accounting due to failure in handling liquidation listings in `Listings::relist()`

* **Severity**: High
* Source: [Incorrect tax accounting due to failure in handling liquidation listings in `Listings::relist()`](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/735)

---
### Description
The [`Listings::relist()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L625-L672) function fails to correctly manage liquidation listings, which do not pay taxes and should not be included in tax calculations. However, the current implementation calculates refunds based on the floor, leading to improper tax usage and incorrect accounting.

---
### Vulnerability Detail

Liquidation listings, created through the [`Listings::createLiquidationListing()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L178-L208) function, are not taxed like normal listings. Regular listings prepay taxes that are used to spend as fees for the [`UniswapImplementation`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L948). If the listing period ends early, users are refunded the unused portion of prepaid taxes. 

However, liquidation listings should be exempt from tax calculations and refunds, but the [`Listings::relist()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L625-L672) function does not properly differentiate between liquidation and regular listings.

This issue arises because the refund is calculated using the floor value, even for liquidation listings that are not subject to taxes. As a result, liquidation listings mistakenly receive tax refunds, which leads to incorrect accounting and fee distribution.

---
### Impact

Incorrect tax is being accounted to liquidation listings, and funds meant for non-liquidation listings are being used improperly. This leads to eligible listings losing part of their prepaid taxes during the relisting process of liquidation listings.

---
### Code Snippet

[Listings::relist()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L625-L672)
```solidity
File: Listings.sol
625:     function relist(CreateListing calldata _listing, bool _payTaxWithEscrow) public nonReentrant lockerNotPaused {
---
643:         // We can process a tax refund for the existing listing
644:@>       (uint _fees,) = _resolveListingTax(oldListing, _collection, true);
645:         if (_fees != 0) {
646:             emit ListingFeeCaptured(_collection, _tokenId, _fees);
647:         }
---
672:     }
```

[Listings::_resolveListingTax()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L918-L956)
```solidity
File: Listings.sol
918:     function _resolveListingTax(Listing memory _listing, address _collection, bool _action) private returns (uint fees_, uint refund_) {
919:         // If we have been passed a Floor item as the listing, then no tax should be handled
920:         if (_listing.owner == address(0)) {
921:             return (fees_, refund_);
922:         }
923: 
924:         // Get the amount of tax in total that will have been paid for this listing
925:         uint taxPaid = getListingTaxRequired(_listing, _collection);
926:         if (taxPaid == 0) {
927:             return (fees_, refund_);
928:         }
929: 
930:         // Get the amount of tax to be refunded. If the listing has already ended
931:         // then no refund will be offered.
932:         if (block.timestamp < _listing.created + _listing.duration) {
933:             refund_ = (_listing.duration - (block.timestamp - _listing.created)) * taxPaid / _listing.duration;
934:         }
935: 
936:         // Send paid tax fees to the {FeeCollector}
937:         unchecked {
938:             fees_ = (taxPaid > refund_) ? taxPaid - refund_ : 0;
939:         }
940: 
941:         if (_action) {
942:             ICollectionToken collectionToken = locker.collectionToken(_collection);
943: 
944:             if (fees_ != 0) {
945:                 IBaseImplementation implementation = locker.implementation();
946: 
947:                 collectionToken.approve(address(implementation), fees_);
948:                 implementation.depositFees(_collection, 0, fees_);
949:             }
950: 
951:             // If there is tax to refund, then allocate it to the user via escrow
952:             if (refund_ != 0) {
953:                 _deposit(_listing.owner, address(collectionToken), refund_);
954:             }
955:         }
956:     }
```

---
### Tool used

Manual Review

---
### Recommendation

Two possible approaches can be taken depending on the desired design:

#### 1. Allow relisting of liquidation listings:

In this approach, ensure that liquidation listings are relisted but do not participate in tax refund calculations or fee distributions since they are exempt from taxes.

```diff
File: Listings.sol

function relist(CreateListing calldata _listing, bool _payTaxWithEscrow) public nonReentrant lockerNotPaused {
---

-    // We can process a tax refund for the existing listing
+    // We can process a tax refund for the existing listing if it isn't a liquidation
+   if (!_isLiquidation[_collection][_tokenId]) {
        (uint _fees,) = _resolveListingTax(oldListing, _collection, true);
        if (_fees != 0) {
            emit ListingFeeCaptured(_collection, _tokenId, _fees);
        }
+   }

---
}
```

#### 2. Do not allow relisting of liquidation listings:

In this approach, prevent liquidation listings from being relisted by reverting the transaction when an attempt to relist is made.

```diff
function relist(uint _listingId, uint _newDuration) external returns (uint listingId) {
---

+   // Revert if attempting to relist a liquidation listing
+   if (_isLiquidation[_collection][_tokenId]) {
+       revert NotAllowLiquidationListing;
+   }

---
}
```
---

## <a name="h-05">[H-05]</a> Incorrect use of `1000` for converting basis points to decimals in `compoundedFactor_` calculation

* **Severity**: High
* Source: [Incorrect use of `1000` for converting basis points to decimals in `compoundedFactor_` calculation](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/736)

---
### Description
The calculation of the compounded factor in the [`TaxCalculator::calculateCompoundedFactor()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/TaxCalculator.sol#L80-L91) incorrectly uses `1000` as the divisor to convert basis points to decimals. Basis points represent two decimal places (e.g., 200 -> 2% -> 0.02) but should use `10000` as the divisor to convert them to decimals (10000 -> 100% -> 1). This mistake causes incorrect interest calculations.

---
### Vulnerability Detail

In the [`TaxCalculator::calculateCompoundedFactor()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/TaxCalculator.sol#L80-L91), the `interestRate` is in basis points with 1e2 precision, and is correctly expanded with 1e18 to match precision for further calculations. 

However, when converting the per-second rate to decimals for compounded factor calculation, the divisor used is `1000`. This is incorrect, as basis points require division by `10000` to represent percentages accurately in decimal format.

The use of 1000 instead of 10000 leads to incorrect calculations for the compounded interest factor, affecting any logic dependent on the compounded interest.

---
### Impact

Overestimation of the compounded interest rate by a factor of 10,000/1,000 = 10x. As a result, users are charged incorrect interest rates. 

The impact of this error grows linearly for utilization rates below the kink (2% -> 8%) and increases rapidly after passing the kink threshold (8% -> 100%).

---
### Code Snippet

[TaxCalculator::calculateCompoundedFactor()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/TaxCalculator.sol#L80-L91)
```solidity
File: TaxCalculator.sol

80:     function calculateCompoundedFactor(uint _previousCompoundedFactor, uint _utilizationRate, uint _timePeriod) public view returns (uint compoundedFactor_) {
81:         // Get our interest rate from our utilization rate
82:         uint interestRate = this.calculateProtectedInterest(_utilizationRate);
83: 
84:         // Ensure we calculate the compounded factor with correct precision. `interestRate` is
85:         // in basis points per annum with 1e2 precision and we convert the annual rate to per
86:         // second rate.
87:         uint perSecondRate = (interestRate * 1e18) / (365 * 24 * 60 * 60);
88: 
89:         // Calculate new compounded factor
90:@>       compoundedFactor_ = _previousCompoundedFactor * (1e18 + (perSecondRate / 1000 * _timePeriod)) / 1e18;
91:     }
```

[TaxCalculator::calculateProtectedInterest()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/TaxCalculator.sol#L46-L71)
```solidity
File: TaxCalculator.sol
46:     /**
--
53:      * @dev The interest rate is returned to 2 decimal places (200 = 2%)
54:      *
55:      * @param _utilizationRate The utilization rate for the collection
56:      *
57:      * @return interestRate_ The annual interest rate for the collection
58:      */
59:     function calculateProtectedInterest(uint _utilizationRate) public pure returns (uint interestRate_) {
60:         // If we haven't reached our kink, then we can just return the base fee
61:         if (_utilizationRate <= UTILIZATION_KINK) {
62:             // Calculate percentage increase for input range 0 to 0.8 ether (2% to 8%)
63:             interestRate_ = 200 + (_utilizationRate * 600) / UTILIZATION_KINK;
64:         }
65:         // If we have passed our kink value, then we need to calculate our additional fee
66:         else {
67:             // Convert value in the range 0.8 to 1 to the respective percentage between 8% and
68:             // 100% and make it accurate to 2 decimal places.
69:             interestRate_ = (((_utilizationRate - UTILIZATION_KINK) * (100 - 8)) / (1 ether - UTILIZATION_KINK) + 8) * 100;
70:         }
71:     }
```

---
### Tool used

Manual Review

---
### Recommendation
Replace the division by `1000` with `10000` when converting the per-second rate to decimal form in the compounded factor calculation

```diff
File: TaxCalculator.sol

80:     function calculateCompoundedFactor(uint _previousCompoundedFactor, uint _utilizationRate, uint _timePeriod) public view returns (uint compoundedFactor_) {
81:         // Get our interest rate from our utilization rate
82:         uint interestRate = this.calculateProtectedInterest(_utilizationRate);
83: 
84:         // Ensure we calculate the compounded factor with correct precision. `interestRate` is
85:         // in basis points per annum with 1e2 precision and we convert the annual rate to per
86:         // second rate.
87:         uint perSecondRate = (interestRate * 1e18) / (365 * 24 * 60 * 60);
88: 
89:         // Calculate new compounded factor
-90:         compoundedFactor_ = _previousCompoundedFactor * (1e18 + (perSecondRate / 1000 * _timePeriod)) / 1e18;
+90:         compoundedFactor_ = _previousCompoundedFactor * (1e18 + (perSecondRate / 10000 * _timePeriod)) / 1e18;
91:     }
```
---

## <a name="h-06">[H-06]</a> Liquidity provider loses Liquidity during collection initialization

* **Severity**: High
* Source: [Liquidity provider loses Liquidity during collection initialization](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/737)

---
### Description
The first liquidity provider initiating the collection through [`Locker::initializeCollection()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L367-L399) loses ownership of their liquidity position due to how the [`UniswapImplementation::_unlockCallback()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/implementation/UniswapImplementation.sol#L376-L420) is executed. The owner of the liquidity position on Uniswap will incorrectly tracks `UniswapImplementation` as the owner of the liquidity.

---
### Vulnerability Detail

When a collection is initialized, the [`UniswapImplementation::_unlockCallback()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/implementation/UniswapImplementation.sol#L376-L420) is used to add the first liquidity to the pool. 

[UniswapImplementation::_unlockCallback()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/implementation/UniswapImplementation.sol#L376-L420)
```solidity
File: UniswapImplementation.sol
376:     function _unlockCallback(bytes calldata _data) internal override returns (bytes memory) {
377:         // Unpack our passed data
378:         CallbackData memory params = abi.decode(_data, (CallbackData));
379: 
380:         // As this call should only come in when we are initializing our pool, we
381:         // don't need to worry about `take` calls, but only `settle` calls.
382:@>         (BalanceDelta delta,) = poolManager.modifyLiquidity({
383:             key: params.poolKey,
384:             params: IPoolManager.ModifyLiquidityParams({
385:                 tickLower: MIN_USABLE_TICK,
386:                 tickUpper: MAX_USABLE_TICK,
387:                 liquidityDelta: int(uint(params.liquidityDelta)),
388:                 salt: ''
389:             }),
390:             hookData: ''
391:         });
---
420:     }
```

However, the `v4-core/PoolManager` uses `msg.sender` as the owner of the position. 

[v4-core/tickbitmap-overload/PoolManager::modifyLiquidity()](https://github.com/Uniswap/v4-core/blob/tickbitmap-overload/src/PoolManager.sol#L164)
```solidity
function modifyLiquidity(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes calldata hookData
) external onlyWhenUnlocked noDelegateCall returns (BalanceDelta 
---
        BalanceDelta principalDelta;
        (principalDelta, feesAccrued) = pool.modifyLiquidity(
            Pool.ModifyLiquidityParams({
                owner: msg.sender, //@note HERE
                tickLower: params.tickLower,
                tickUpper: params.tickUpper,
                liquidityDelta: params.liquidityDelta.toInt128(),
                tickSpacing: key.tickSpacing,
                salt: params.salt
            })
        );
---
}
```

In this case, `UniswapImplementation` contract **becomes the owner of the liquidity position, not the user who initiated the `Locker::initializeCollection()`**. 

As a result, the user who provided the initial liquidity has no control over the position they created.

---
### Impact

The user who initiates the collection and provides the first liquidity will lose ownership of their liquidity position.

---
### Code Snippet

[UniswapImplementation::_unlockCallback()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/implementation/UniswapImplementation.sol#L376-L420)
```solidity
File: UniswapImplementation.sol
376:     function _unlockCallback(bytes calldata _data) internal override returns (bytes memory) {
377:         // Unpack our passed data
378:         CallbackData memory params = abi.decode(_data, (CallbackData));
379: 
380:         // As this call should only come in when we are initializing our pool, we
381:         // don't need to worry about `take` calls, but only `settle` calls.
382:@>         (BalanceDelta delta,) = poolManager.modifyLiquidity({
383:             key: params.poolKey,
384:             params: IPoolManager.ModifyLiquidityParams({
385:                 tickLower: MIN_USABLE_TICK,
386:                 tickUpper: MAX_USABLE_TICK,
387:                 liquidityDelta: int(uint(params.liquidityDelta)),
388:                 salt: ''
389:             }),
390:             hookData: ''
391:         });
---
420:     }
```

[v4-core/tickbitmap-overload/PoolManager::modifyLiquidity()](https://github.com/Uniswap/v4-core/blob/tickbitmap-overload/src/PoolManager.sol#L164)
```solidity
function modifyLiquidity(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes calldata hookData
) external onlyWhenUnlocked noDelegateCall returns (BalanceDelta 
---
        BalanceDelta principalDelta;
        (principalDelta, feesAccrued) = pool.modifyLiquidity(
            Pool.ModifyLiquidityParams({
                owner: msg.sender, //@note HERE
                tickLower: params.tickLower,
                tickUpper: params.tickUpper,
                liquidityDelta: params.liquidityDelta.toInt128(),
                tickSpacing: key.tickSpacing,
                salt: params.salt
            })
        );
---
}
```

[UniswapImplementation::initializeCollection()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/implementation/UniswapImplementation.sol#L205-L240)
```solidity
File: UniswapImplementation.sol
205:     function initializeCollection(address _collection, uint _amount0, uint _amount1, uint _amount1Slippage, uint160 _sqrtPriceX96) public override {
206:         // Ensure that only our {Locker} can call initialize
207:         if (msg.sender != address(locker)) revert CallerIsNotLocker();
---
225:         // Obtain the UV4 lock for the pool to pull in liquidity
226:         poolManager.unlock(
227:             abi.encode(CallbackData({
228:                 poolKey: poolKey,
229:                 liquidityDelta: LiquidityAmounts.getLiquidityForAmounts({
230:                     sqrtPriceX96: _sqrtPriceX96,
231:                     sqrtPriceAX96: TICK_SQRT_PRICEAX96,
232:                     sqrtPriceBX96: TICK_SQRT_PRICEBX96,
233:                     amount0: poolParams.currencyFlipped ? _amount1 : _amount0,
234:                     amount1: poolParams.currencyFlipped ? _amount0 : _amount1
235:                 }),
236:                 liquidityTokens: _amount1,
237:                 liquidityTokenSlippage: _amount1Slippage
238:             })
239:         ));
240:     }
```

[Locker::initializeCollection()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L367-L399)
```solidity
File: Locker.sol
367:     function initializeCollection(address _collection, uint _eth, uint[] calldata _tokenIds, uint _tokenSlippage, uint160 _sqrtPriceX96) public virtual whenNotPaused collectionExists(_collection) {
368:         // Ensure the collection is not already initialised
---
384:         nativeToken.transferFrom(msg.sender, address(_implementation), _eth);
385: 
---
388:         _implementation.initializeCollection(_collection, _eth, tokens, _tokenSlippage, _sqrtPriceX96);
389: 
---
399:     }
```

---
### Tool used

Manual Review

---
### Recommendation

Given that `v4-core/PoolManager::modifyLiquidity()` uses `msg.sender` as the owner and the Uniswap contract cannot be altered, consider the following strategies to address ownership concerns:

* Use a `PositionManager` to handle liquidity positions for different users, ensuring users retain control.

* Use the salt parameter to differentiate same-range positions, helping manage positions for multiple users.

* Set up an external tracking system and facilitate liquidity withdrawal to verify and manage ownership for initial liquidity providers.

---

## <a name="h-07">[H-07]</a> The attacker will prevent eligible users from claiming the liquidated balance

* **Severity**: High
* Source: [The attacker will prevent eligible users from claiming the liquidated balance](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/742)

---
### Description
The `CollectionShutdown` contract has vulnerabilities allowing a malicious actor to prevent eligible users from claiming the liquidated balance after liquidation by SudoSwap.

---
### Root Cause

1. The [`CollectionShutdown::vote()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L175-L181) does not prevent voting after the collection shutdown is executed and/or during the claim state, allowing malicious actors to trigger `canExecute` to `TRUE` after execution.
2. The [`CollectionShutdown::cancel()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L390-L405) does not use `params.collectionToken` to retrieve the `denomination()` for validating the total supply during cancellation, which opens the door to manipulations that can bypass the checks.

---
### Internal pre-conditions

1. The collection token total supply must be within a valid limit for the shutdown condition (e.g., less than or equal to `MAX_SHUTDOWN_TOKENS`).
2. The `denomination` of the collection token for the shutdown collection is greater than 0.

---
### External pre-conditions

1. The attacker holds some portion of the collection token supply for the shutdown collection.

---
### Attack Path

#### Pre-condition: 
1. Assume the collection token (CT) total supply is 4 CTs (`4 * 1e18 * 10 ** denom`).
2. There are 2 holders of this supply: **Lewis (2 CTs)** and **Max (2 CTs)**.

#### Attack:
1. Lewis notices that the collection can be shutdown and calls `CollectionShutdown::start()`.
    * `totalSupply` meets the condition `<= MAX_SHUTDOWN_TOKENS`.
    * `params.quorumVotes` = 50% of totalSupply = `2 * 1e18 * 1eDenom` (2 CTs).
    * Vote for Lewis is recorded.
    * The contract transfer 2 CTs of Lewis balances, and `params.shutdownVotes += 2 CTs`.
    * Now `params.canExecute` is flagged to be `TRUE` since `params.shutdownVotes (2CTs) >= params.quorumVotes (2 CTs)`.

2. Time passes, no cancellation occurs, and the owner executes the pending shutdown.
    * The NFTs are liquidated on SudoSwap.
    * `params.quorumVotes` remains the same as there is no change in supply.
    * The collection is sunset in the `Locker`, deleting `_collectionToken[_collection]` and `collectionInitialized[_collection]`.
    * `params.canExecute` is flagged back to `FALSE`.

**After some or all NFTs are sold on SudoSwap:**

3. Max monitors the NFT sales and prepares for the attack.
4. Max splits their balance of CTs to his another wallet and remains holding a small amount to perform the attack.
5. Max, who never voted, calls `CollectionShutdown::vote()` to **flag `params.canExecute` back to `TRUE`**.
    * The contract transfer small amount of CTs of Max balances.
    * Since `params.shutdownVotes >= params.quorumVotes` (due to Lewis' shutdown), `params.canExecute` is set back to `TRUE`.

6. Max registers the target collection again, manipulating the token's `denomination` via the `Locker::createCollection()`.
    * Max specifies a `denomination` lower than the previous one (e.g., previously 4, now 0).
    
7. Max invokes `CollectionShutdown::cancel()` to remove all properties of `_collectionParams[_collection]`, including `_collectionParams[].availableClaim`.
    * The following check passes:
    ```solidity
    File: CollectionShutdown.sol
    398:         if (params.collectionToken.totalSupply() <= MAX_SHUTDOWN_TOKENS * 10 ** locker.collectionToken(_collection).denomination()) {
    399:             revert InsufficientTotalSupplyToCancel();
    400:         }
    ```
    * Since the new denomination is 0, the check becomes:
    ```solidity
    (4 * 1e18 * 10 ** 4) <= (4 * 1e18 * 10 ** 0): FALSE
    ```
**Result**: This check passes, allowing Max to cancel and prevent Lewis from claiming their eligible ETH from SudoSwap.

---
### Impact

The attack allows a malicious actor to prevent legitimate token holders from claiming their eligible NFT sale proceeds from SudoSwap. This could lead to significant financial losses for affected users.

---
### PoC

#### Setup
* Update the [`CollectionShutdown.t::constructor()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/test/utils/CollectionShutdown.t.sol#L35) to mint CTs token with denominator more that 0
```diff
File: CollectionShutdown.t.sol
29:     constructor () forkBlock(19_425_694) {
30:         // Deploy our platform contracts
31:         _deployPlatform();
---
-35:         locker.createCollection(address(erc721b), 'Test Collection', 'TEST', 0);
+35:         locker.createCollection(address(erc721b), 'Test Collection', 'TEST', 4);
36: 
```
* Put the snippet below into the protocol test suite: `flayer/test/utils/CollectionShutdown.t.sol` 
* Run test:
`forge test --mt test_CanBlockEligibleUsersToClaim -vvv`

#### Coded PoC
<details>
  <summary>Coded PoC</summary>

```solidity
        function test_CanBlockEligibleUsersToClaim() public {
        address Lewis = makeAddr("Lewis");
        address Max = makeAddr("Max");
        address MaxRecovery = makeAddr("MaxRecovery");

        // -- Before Attack --
        
        // Mint some tokens to our test users -> totalSupply: 4 ethers (can shutdown)
        vm.startPrank(address(locker));
        collectionToken.mint(Lewis, 2 ether * 10 ** collectionToken.denomination());
        collectionToken.mint(Max, 2 ether * 10 ** collectionToken.denomination());
        vm.stopPrank();

        // Start shutdown with their vore that has passed the threshold quorum
        vm.startPrank(Lewis);
        uint256 lewisVoteBalance = 2 ether * 10 ** collectionToken.denomination();
        collectionToken.approve(address(collectionShutdown), type(uint256).max);
        collectionShutdown.start(address(erc721b));
        assertEq(collectionShutdown.shutdownVoters(address(erc721b), address(Lewis)), lewisVoteBalance);
        vm.stopPrank();

        // Confirm that we can now execute
        assertCanExecute(address(erc721b), true);

        // Mint NFTs into our collection {Locker} and process the execution
        uint[] memory tokenIds = _mintTokensIntoCollection(erc721b, 3);
        collectionShutdown.execute(address(erc721b), tokenIds);

        // Confirm that the {CollectionToken} has been sunset from our {Locker}
        assertEq(address(locker.collectionToken(address(erc721b))), address(0));

        // After we have executed, we should no longer have an execute flag
        assertCanExecute(address(erc721b), false);

        // Mock the process of the Sudoswap pool liquidating the NFTs for ETH. This will
        // provide 0.5 ETH <-> 1 {CollectionToken}.
        _mockSudoswapLiquidation(SUDOSWAP_POOL, tokenIds, 2 ether);

        // Ensure that all state are SET
        ICollectionShutdown.CollectionShutdownParams memory shutdownParamsBefore = collectionShutdown.collectionParams(address(erc721b));
        assertEq(shutdownParamsBefore.shutdownVotes, lewisVoteBalance);
        assertEq(shutdownParamsBefore.sweeperPool, SUDOSWAP_POOL);
        assertEq(shutdownParamsBefore.quorumVotes, lewisVoteBalance);
        assertEq(shutdownParamsBefore.canExecute, false);
        assertEq(address(shutdownParamsBefore.collectionToken), address(collectionToken));
        assertEq(shutdownParamsBefore.availableClaim, 2 ether);

        // -- Attack --
        uint256 balanceOfMaxBefore = collectionToken.balanceOf(address(Max));
        uint256 amountSpendForAttack = 1;

        // Transfer almost full funds to their second account and perform with small amount
        vm.prank(Max);
        collectionToken.transfer(address(MaxRecovery), balanceOfMaxBefore - amountSpendForAttack);
        uint256 balanceOfMaxAfter = collectionToken.balanceOf(address(Max));
        assertEq(balanceOfMaxAfter, amountSpendForAttack);

        // Max votes even it is in the claim state to flag the `canExecute` back to Trrue
        vm.startPrank(Max);
        collectionToken.approve(address(collectionShutdown), type(uint256).max);
        collectionShutdown.vote(address(erc721b));
        assertEq(collectionShutdown.shutdownVoters(address(erc721b), address(Max)), amountSpendForAttack);
        vm.stopPrank();

        // Confirm that Max can now flag `canExecute` back to `TRUE`
        assertCanExecute(address(erc721b), true);

        // Attack to delete all varaibles track, resulting others cannot claim thier eligible ethers
        vm.startPrank(Max);
        locker.createCollection(address(erc721b), 'Test Collection', 'TEST', 0);
        collectionShutdown.cancel(address(erc721b));
        vm.stopPrank();

        // Ensure that all state are DELETE
        ICollectionShutdown.CollectionShutdownParams memory shutdownParamsAfter = collectionShutdown.collectionParams(address(erc721b));
        assertEq(shutdownParamsAfter.shutdownVotes, 0);
        assertEq(shutdownParamsAfter.sweeperPool, address(0));
        assertEq(shutdownParamsAfter.quorumVotes, 0);
        assertEq(shutdownParamsAfter.canExecute, false);
        assertEq(address(shutdownParamsAfter.collectionToken), address(0));
        assertEq(shutdownParamsAfter.availableClaim, 0);

        // -- After Attack --
        vm.expectRevert();
        vm.prank(Lewis);
        collectionShutdown.claim(address(erc721b), payable(Lewis));
    }
```
</details>

#### Result
Results of running the test:
```bash
Ran 1 test for test/utils/CollectionShutdown.t.sol:CollectionShutdownTest
[PASS] test_CanBlockEligibleUsersToClaim() (gas: 1491640)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 10.96s (3.48ms CPU time)

Ran 1 test suite in 11.17s (10.96s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

---
### Mitigation

* Add validations to prevent manipulation of the CT denomination, and restrict voting during the claim state to prevent re-triggering of `params.canExecute`.
```diff
function vote(address _collection) public nonReentrant whenNotPaused {
    // Ensure that we are within the shutdown window
    CollectionShutdownParams memory params = _collectionParams[_collection];
    if (params.quorumVotes == 0) revert ShutdownProccessNotStarted();
+   if (params.sweeperPool != address(0)) revert ShutdownExecuted();
    _collectionParams[_collection] = _vote(_collection, params);
}
```

* Update the usage of token denomination to use the token depens on the tracked token to inconsisten value.
```diff
function cancel(address _collection) public whenNotPaused {
    // Ensure that the vote count has reached quorum
    CollectionShutdownParams memory params = _collectionParams[_collection];
    if (!params.canExecute) revert ShutdownNotReachedQuorum();

    // Check if the total supply has surpassed an amount of the initial required
    // total supply. This would indicate that a collection has grown since the
    // initial shutdown was triggered and could result in an unsuspected liquidation.
-    if (params.collectionToken.totalSupply() <= MAX_SHUTDOWN_TOKENS * 10 ** locker.collectionToken(_collection).denomination()) {
+    if (params.collectionToken.totalSupply() <= MAX_SHUTDOWN_TOKENS * 10 ** params.collectionToken.denomination()) {
        revert InsufficientTotalSupplyToCancel();
    }

    // Remove our execution flag
    delete _collectionParams[_collection];
    emit CollectionShutdownCancelled(_collection);
}
```
---

## <a name="h-08">[H-08]</a> Failure to delete the listing when it is reserved

* **Severity**: High
* Source: [Failure to delete the listing when it is reserved](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/743)

---
### Description
The [`Listings::reserve()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L690-L759) function fails to delete listings after they are moved to the `ProtectedListing` contract, resulting in outdated data remaining in the `Listing` contract. 

This failure to delete listings can lead to the misuse of listing data, causing issues in functions such as `modifyListings()`, `cancelListings()`, `fillListings()` and others that interact with listings.

---
### Vulnerability Detail

The [`Listings::reserve()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L690-L759) function does not properly remove the listing from the `Listing` contract once the token listing is transferred to the `ProtectedListing` contract. 

As a result, the outdated listing data persists and can be inadvertently used in various functions within the `Listing` contract. This can cause incorrect behavior and inaccuracies in processing, as the reserved/protected listing should not be available for further interactions unless it is liquidated from the `ProtectedListing` contract.

---
### Impact

Incorrect usage of non-existent listing data leads to several issues, including incorrect tax accounting, incorrect reserve adjustments, and the misuse of outdated listing data in various critical functions.

---
### Code Snippet

[Listings::reserve()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Listings.sol#L690-L759)
```solidity
File: Listings.sol
690:     function reserve(address _collection, uint _tokenId, uint _collateral) public nonReentrant lockerNotPaused {
---
704:         // Check if the listing is a floor item and process additional logic if there
705:         // was an owner (meaning it was not floor, so liquid or dutch).
706:         if (oldListing.owner != address(0)) {
707:             // We can process a tax refund for the existing listing if it isn't a liquidation
708:             if (!_isLiquidation[_collection][_tokenId]) {
709:                 (uint _fees,) = _resolveListingTax(oldListing, _collection, true);
710:                 if (_fees != 0) {
711:                     emit ListingFeeCaptured(_collection, _tokenId, _fees);
712:                 }
713:             }
714: 
715:             // If the floor multiple of the original listings is different, then this needs
716:             // to be paid to the original owner of the listing.
717:             uint listingFloorPrice = 1 ether * 10 ** collectionToken.denomination();
718:             if (listingPrice > listingFloorPrice) {
719:                 unchecked {
720:                     collectionToken.transferFrom(msg.sender, oldListing.owner, listingPrice - listingFloorPrice);
721:                 }
722:             }
723: 
724:             // Reduce the amount of listings
725:@>           unchecked { listingCount[_collection] -= 1; }
726:         }
---
750:         // Create our listing, receiving the ERC20 into this contract
751:@>       protectedListings.createListings(createProtectedListing);
---
759:     }
```

---
### Tool used

Manual Review

---
### Recommendation

Delete the listing after it is reserved and moved to the `ProtectedListings` contract. Additionally, for the reservation of liquidation listings, the liquidation status should be reset.

```diff
function reserve(address _collection, uint _tokenId, uint _collateral) public nonReentrant lockerNotPaused {
---
    if (oldListing.owner != address(0)) {
        // We can process a tax refund for the existing listing if it isn't a liquidation
        if (!_isLiquidation[_collection][_tokenId]) {
            (uint _fees,) = _resolveListingTax(oldListing, _collection, true);
            if (_fees != 0) {
                emit ListingFeeCaptured(_collection, _tokenId, _fees);
            }
-        }
+        } else {
+           delete _isLiquidation[_collection][_tokenId];
+        }
        
        // If the floor multiple of the original listings is different, then this needs
        // to be paid to the original owner of the listing.
        uint listingFloorPrice = 1 ether * 10 ** collectionToken.denomination();
        if (listingPrice > listingFloorPrice) {
            unchecked {
                collectionToken.transferFrom(msg.sender, oldListing.owner, listingPrice - listingFloorPrice);
            }
        }

        // Reduce the amount of listings
        unchecked { listingCount[_collection] -= 1; }

+       // Delete the token listing
+        delete _listings[_collection][_tokenId];
    }
---
}
```
---

## <a name="m-01">[M-01]</a> Inability to shutdown/sunset a newly registered collection after previous shutdown

* **Severity**: Medium
* Source: [Inability to shutdown/sunset a newly registered collection after previous shutdown](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/724)

---
### Description
The `shutdownVotes` parameter is not cleared after a collection shutdown is executed and claimed. This issue prevents a previously shut down collection from being eligible for a new shutdown/sunset process if it is re-registered.

---
### Vulnerability Detail

When the `CollectionShutdown` contract executes and then the claim process occurs, it fails to update or clear the `shutdownVotes` parameter, which is used to track votes related to the shutdown process.

[CollectionShutdown::claim()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L285-L315)
```solidity
File: CollectionShutdown.sol
285:     function claim(address _collection, address payable _claimant) public nonReentrant whenNotPaused {
286:         // Ensure our user has tokens to claim
287:         uint claimableVotes = shutdownVoters[_collection][_claimant];
288:         if (claimableVotes == 0) revert NoTokensAvailableToClaim();
289: 
290:         // Ensure that we have moved token IDs to the pool
291:         CollectionShutdownParams memory params = _collectionParams[_collection];
292:         if (params.sweeperPool == address(0)) revert ShutdownNotExecuted();
293: 
294:         // Ensure that all NFTs have sold from our Sudoswap pool
295:         if (!collectionLiquidationComplete(_collection)) revert NotAllTokensSold();
296: 
297:         // We can now delete our sweeper pool tokenIds
298:         if (params.sweeperPoolTokenIds.length != 0) {
299:             delete _collectionParams[_collection].sweeperPoolTokenIds;
300:         }
301: 
302:         // Burn the tokens from our supply
303:         params.collectionToken.burn(claimableVotes);
304: 
305:         // Set our available tokens to claim to zero
306:         delete shutdownVoters[_collection][_claimant];
307: 
308:         // Get the number of votes from the claimant and the total supply and determine from that the percentage
309:         // of the available funds that they are able to claim.
310:         uint amount = params.availableClaim * claimableVotes / (params.quorumVotes * ONE_HUNDRED_PERCENT / SHUTDOWN_QUORUM_PERCENT);
311:         (bool sent,) = _claimant.call{value: amount}('');
312:         if (!sent) revert FailedToClaim();
313: 
314:         emit CollectionShutdownClaim(_collection, _claimant, claimableVotes, amount);
315:     }
```

If a collection that was previously shut down is re-registered with the `Locker`, it will not be eligible for a new shutdown/sunset process because the `shutdownVotes` from the previous shutdown remain unchanged.

[CollectionShutdown::start()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L135-L157)
```solidity
File: CollectionShutdown.sol
135:     function start(address _collection) public whenNotPaused {
136:         // Confirm that this collection is not prevented from being shutdown
137:         if (shutdownPrevented[_collection]) revert ShutdownPrevented();
138: 
139:         // Ensure that a shutdown process is not already actioned
140:         CollectionShutdownParams memory params = _collectionParams[_collection];
141:@>       if (params.shutdownVotes != 0) revert ShutdownProcessAlreadyStarted();
---
157:     }
```

---
### Impact

Prevents the `CollectionShutdown` contract from correctly processing a **new** shutdown/sunset request for a collection that has been previously shut down. This results in the collection being unable to be shut down again, even if it is re-registered.

---
### Code Snippet

[CollectionShutdown::claim()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L285-L315)
```solidity
File: CollectionShutdown.sol
285:     function claim(address _collection, address payable _claimant) public nonReentrant whenNotPaused {
286:         // Ensure our user has tokens to claim
287:         uint claimableVotes = shutdownVoters[_collection][_claimant];
288:         if (claimableVotes == 0) revert NoTokensAvailableToClaim();
289: 
290:         // Ensure that we have moved token IDs to the pool
291:         CollectionShutdownParams memory params = _collectionParams[_collection];
292:         if (params.sweeperPool == address(0)) revert ShutdownNotExecuted();
293: 
294:         // Ensure that all NFTs have sold from our Sudoswap pool
295:         if (!collectionLiquidationComplete(_collection)) revert NotAllTokensSold();
296: 
297:         // We can now delete our sweeper pool tokenIds
298:         if (params.sweeperPoolTokenIds.length != 0) {
299:             delete _collectionParams[_collection].sweeperPoolTokenIds;
300:         }
301: 
302:         // Burn the tokens from our supply
303:         params.collectionToken.burn(claimableVotes);
304: 
305:         // Set our available tokens to claim to zero
306:         delete shutdownVoters[_collection][_claimant];
307: 
308:         // Get the number of votes from the claimant and the total supply and determine from that the percentage
309:         // of the available funds that they are able to claim.
310:         uint amount = params.availableClaim * claimableVotes / (params.quorumVotes * ONE_HUNDRED_PERCENT / SHUTDOWN_QUORUM_PERCENT);
311:         (bool sent,) = _claimant.call{value: amount}('');
312:         if (!sent) revert FailedToClaim();
313: 
314:         emit CollectionShutdownClaim(_collection, _claimant, claimableVotes, amount);
315:     }
```

[CollectionShutdown::start()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L135-L157)
```solidity
File: CollectionShutdown.sol
135:     function start(address _collection) public whenNotPaused {
136:         // Confirm that this collection is not prevented from being shutdown
137:         if (shutdownPrevented[_collection]) revert ShutdownPrevented();
138: 
139:         // Ensure that a shutdown process is not already actioned
140:         CollectionShutdownParams memory params = _collectionParams[_collection];
141:@>       if (params.shutdownVotes != 0) revert ShutdownProcessAlreadyStarted();
---
157:     }
```

---
### Tool used

Manual Review

---
### Recommendation

Update the `params.shutdownVoters` when claiming to reduce global votes. 


```diff
function claim(address _collection, address payable _claimant) public nonReentrant whenNotPaused {
    // Ensure our user has tokens to claim
    uint claimableVotes = shutdownVoters[_collection][_claimant];
    if (claimableVotes == 0) revert NoTokensAvailableToClaim();
---

+   params.shutdownVotes -= claimableVotes;

    emit CollectionShutdownClaim(_collection, _claimant, claimableVotes, amount);
}
```

```diff
function reclaimVote(address _collection) public whenNotPaused {
    // If the quorum has passed, then we can no longer reclaim as we are pending
    // an execution.
    CollectionShutdownParams storage params = _collectionParams[_collection];
    if (params.canExecute) revert ShutdownQuorumHasPassed();
+   if (params.sweeperPool != address(0)) revert ShutdownExecuted(); // prevent from reclaim after executed
---
}
```

However, **this approach raises another concern**: the `params.shutdownVoters` represents votes from users, which could potentially lead to an imbalance in the total value relative to the supply. 

In a scenario where all claimers reclaim their votes, `params.shutdownVoters` would revert to zero, enabling a new shutdown process. However, users who hold collection tokens but haven‚Äôt voted (or claimed via [`CollectionShutdown::voteAndClaim()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/utils/CollectionShutdown.sol#L323-L348)) will be affected. If the collection is re-registered and undergoes another shutdown, those non-voting users could lose the ability to claim rewards, as new tokens might be minted for the re-registered collection, leaving their tokens unaccounted for.
This concern should be evaluated based on the specific business logic in place.

---

## <a name="m-02">[M-02]</a> Refund logic in `Locker::initializeCollection()` incorrectly handles the return of unused tokens

* **Severity**: Medium
* Source: [Refund logic in `Locker::initializeCollection()` incorrectly handles the return of unused tokens](https://github.com/sherlock-audit/2024-08-flayer-judging/issues/728)

---
### Description
The refund logic in the [`Locker::initializeCollection()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L367-L399) fails to work as intended. `nativeToken`s are transferred from the user to the `implementation` contract, but no tokens are transferred to the Locker contract. 

As a result, the process designed to refund unused native tokens to the user during the creation of initial liquidity does not execute correctly, leading to no refunds being made.

---
### Vulnerability Detail

When the [`Locker::initializeCollection()`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L367-L399) function is called, it attempts to refund any unused native tokens back to the user. However, the logic does not work as intended because the tokens are transferred from the user to the `implementation` contract, and there is no token transfer to the `Locker` contract.

[Locker::initializeCollection()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L367-L399)
```solidity
File: Locker.sol
367:     function initializeCollection(address _collection, uint _eth, uint[] calldata _tokenIds, uint _tokenSlippage, uint160 _sqrtPriceX96) public virtual whenNotPaused collectionExists(_collection) {
---
379:         // Convert the tokens into ERC20's which will return at a rate of 1:1
380:         deposit(_collection, _tokenIds, address(_implementation));
---
382:         // Send the native ETH equivalent token into the implementation
383:         uint startBalance = nativeToken.balanceOf(address(this));
384:@>       nativeToken.transferFrom(msg.sender, address(_implementation), _eth);
---
388:         _implementation.initializeCollection(_collection, _eth, tokens, _tokenSlippage, _sqrtPriceX96);
---
394:         // Refund any unused relative token to the user
395:@>       nativeToken.transfer(
396:             msg.sender,
397:             startBalance - nativeToken.balanceOf(address(this))
398:         );
399:     }
```

As a result, no refunds are made to the user. The logic assumes that if there are unused tokens after liquidity is provided, those tokens should be refunded, but this process fails.

Furthermore, this issue does not aim to address user mistakes in specifying excessive native tokens beyond the required price. Instead, the issue lies in the logic designed to refund unused tokens that were intended to provide liquidity at the specified price.

---
### Impact

The logic does not work as intended, and users who provide liquidity might end up losing their unused tokens, as the system fails to refund any leftover tokens.

---
### Code Snippet

[Locker::initializeCollection()](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/Locker.sol#L367-L399)
```solidity
File: Locker.sol
367:     function initializeCollection(address _collection, uint _eth, uint[] calldata _tokenIds, uint _tokenSlippage, uint160 _sqrtPriceX96) public virtual whenNotPaused collectionExists(_collection) {
---
379:         // Convert the tokens into ERC20's which will return at a rate of 1:1
380:         deposit(_collection, _tokenIds, address(_implementation));
---
382:         // Send the native ETH equivalent token into the implementation
383:         uint startBalance = nativeToken.balanceOf(address(this));
384:@>       nativeToken.transferFrom(msg.sender, address(_implementation), _eth);
---
388:         _implementation.initializeCollection(_collection, _eth, tokens, _tokenSlippage, _sqrtPriceX96);
---
394:         // Refund any unused relative token to the user
395:@>       nativeToken.transfer(
396:             msg.sender,
397:             startBalance - nativeToken.balanceOf(address(this))
398:         );
399:     }
```

---
### Tool used

Manual Review

---
### Recommendation

In the context of the contest, the `implementation` contract refers to the [`UniswapImplementation`](https://github.com/sherlock-audit/2024-08-flayer/blob/main/flayer/src/contracts/implementation/UniswapImplementation.sol) contract. Therefore, the recommendations will be based on this code.

```diff
File: Locker.sol
function initializeCollection(address _collection, uint _eth, uint[] calldata _tokenIds, uint _tokenSlippage, uint160 _sqrtPriceX96) public virtual whenNotPaused collectionExists(_collection) {

---
     // Send the native ETH equivalent token into the implementation
     uint startBalance = nativeToken.balanceOf(address(this));
     nativeToken.transferFrom(msg.sender, address(_implementation), _eth);

---

    _implementation.initializeCollection(_collection, _eth, tokens, _tokenSlippage, _sqrtPriceX96);

---
    // Refund any unused relative token to the user
    nativeToken.transfer(
        msg.sender,
-       startBalance - nativeToken.balanceOf(address(this))
+       nativeToken.balanceOf(address(this)) - startBalance
    );
}
```

```diff
File: UniswapImplementation.sol
function initializeCollection(address _collection, uint _amount0, uint _amount1, uint _amount1Slippage, uint160 _sqrtPriceX96) public override {
    // Ensure that only our {Locker} can call initialize
    if (msg.sender != address(locker)) revert CallerIsNotLocker();
+   Currency _nativeCurrency = poolParams.currencyFlipped ? poolKey.currency1 : poolKey.currency0;
+   uint256 startNativeBalance = _nativeCurrency.balanceOfSelf();
---
    // Obtain the UV4 lock for the pool to pull in liquidity
    poolManager.unlock(
        abi.encode(CallbackData({
            poolKey: poolKey,
            liquidityDelta: LiquidityAmounts.getLiquidityForAmounts({
                sqrtPriceX96: _sqrtPriceX96,
                sqrtPriceAX96: TICK_SQRT_PRICEAX96,
                sqrtPriceBX96: TICK_SQRT_PRICEBX96,
                amount0: poolParams.currencyFlipped ? _amount1 : _amount0,
                amount1: poolParams.currencyFlipped ? _amount0 : _amount1
            }),
            liquidityTokens: _amount1,
            liquidityTokenSlippage: _amount1Slippage
        })
    ));

+    uint256 afterNativeBalance = _nativeCurrency.balanceOfSelf();
+    if ((startNativeBalance - afterNativeBalance) > 0){
+        SafeTransferLib.safeTransfer(Currency.unwrap(_currency), msg.sender, (startNativeBalance - afterNativeBalance));
    }
}
```
---