# Yeet - Audit Competition Report
Yeet is a gamified DeFi protocol on Berachain that offers an interactive financial experience through
strategy and timing. Its core feature, the Yeet Game, allows users to deposit BERA tokens into a pool,
with the last depositor winning most of the funds. YeetBonds help protocols manage their liquidity
efficiently, while Yeetard NFTs provide additional in-game benefits.

The native $YEET token can be farmed and staked for rewards. By integrating game mechanics into
DeFi, Yeet fosters community engagement, liquidity solutions, and a unique way to participate in
decentralized finance.

For more information about Yeet, please visit https://www.yeetit.xyz/

* **nSLOC**: 1,538 
* **Contest details**: https://codehawks.cyfrin.io/c/2024-07-biconomy

## Disclaimer
This report contains the valid findings discovered by me (merlinboii). 

Severity Criteria: 
* [Severity Classification System | Immunefi](https://immunefisupport.zendesk.com/hc/en-us/articles/13333032674961-Severity-Classification-System)

---

## Findings

| ID | Description | Severity |
| :-: | - | :-: |
|[C-01](#c-01)| Unstaked tokens incorrectly counted as rewards during vesting period |üçí|
|[H-01](#h-01)| Attacker can DoS `StakeV2`'s rewards distribution by repeatedly inflating Zapper's approval for whitelisted Kodiak Vault tokens |üçÖ|
|[H-02](#h-02)| Permanent freezing of yield due to incorrect reward handling in `StakeV2` claim functions |üçÖ|
|[L-01](#l-01)| Full or Large WBERA reward collects can be blocked by small amounts |ü´ë|
|[L-02](#l-02)| Incorrect `maxWithdraw()` returns lead to user failed withdrawals of returned maximum amount |ü´ë|
|[I-01](#i-01)| Previous owner still hold manager role after ownership transfer |ü´ê|

---

## <a name="c-01">[C-01]</a> Unstaked tokens incorrectly counted as rewards during vesting period

* **Severity**: Critical
* Source: [Unstaked tokens incorrectly counted as rewards during vesting period](https://reports.immunefi.com/yeet/41521-sc-critical-unstaked-tokens-incorrectly-counted-as-rewards-during-vesting-period)
---
### Brief/Intro
**An accounting error in `StakeV2` causes unstaked tokens in vesting to be incorrectly counted as rewards**. This could lead to **unintended loss of funds for stakers** and **potential insolvency for the protocol**.

---
### Vulnerability Details
The `accumulatedDeptRewardsYeet()` function **does not account for unstaked tokens during the vesting period**:

```solidity
function accumulatedDeptRewardsYeet() public view returns (uint256) {
@>  return stakingToken.balanceOf(address(this)) - totalSupply;
}
```

Since `totalSupply` is reduced immediately for the `unstakeAmount` at `startUnstake()`, while the unstaked amount remains in the contract during vesting, **`accumulatedDeptRewardsYeet()` mistakenly includes this unstaked amount as part of the rewards**. Consequently, **when `executeRewardDistributionYeet()` is called, these mistakenly counted rewards are distributed to stakers, leading to an unintended loss of funds**.

```solidity
function startUnstake(uint256 unStakeAmount) external {
    --- SNIPPED ---

    balanceOf[msg.sender] -= unStakeAmount;
@>  totalSupply -= unStakeAmount;

    uint256 start = block.timestamp;
    uint256 end = start + VESTING_PERIOD;
    vestings[msg.sender].push(Vesting(unStakeAmount, start, end));
    stakedTimes[msg.sender]++;  
    emit VestingStarted(msg.sender, unStakeAmount, vestings[msg.sender].length - 1);
}
```
---
### Impact Details
Consider the following scenario:
0. Users A and B each stake 100e18 YEET
    - Contract State:
        - `YEET.balance(StakeV2)`: 200e18
        - `totalSupply`: 200e18
        - Real rewards: 0

1. B starts unstaking 100e18 YEET
    - Contract State:
        - `YEET.balance(StakeV2)`: 200e18 (unchanged)
        - `totalSupply`: 100e18 (reduced by B's unstake)
        - Tokens in vesting: 100e18 (B's unstaking amount)

2. Manager Distributes "Rewards": 
    - `accumulatedDeptRewardsYeet()` returns: 200e18 - 100e18 = 100e18
    - These rewards (actually B's vesting tokens) are distributed
    - Contract State:
        - `YEET.balance(StakeV2)`: 100e18
        - `totalSupply`: 100e18
        - **Tokens distributed as "rewards": 100e18**

3. B finalizes unstake at vesting period ends and withdraws their 100e18 YEET
    - Final Contract State:
        - `YEET.balance(StakeV2)`: 0
        - `totalSupply`: 100e18 (A's stake)
        - **Result: A's stake becomes unbacked by tokens**

This **scenario demonstrates the following impacts**: 
1. **User A suffers a complete loss of their 100e18 YEET stake** as they cannot unstake due to insufficient contract balance
2. **The protocol becomes technically insolvent** as it owes User A 100e18 YEET but has 0 balance
3. **The lack of vesting token tracking allows the manager to unknowingly distribute vesting tokens as rewards through `accumulatedDeptRewardsYeet()`, creating a HIGH likelihood**.


#### The severity assessment

This issue qualifies as `Direct theft of any user funds` because:
1. Stakers lose their entire principal investment
2. The loss occurs while funds are at-rest in the staking contract
3. The vulnerability allows one user (B) to profit at the expense of another (A)
---
### References
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L247-L262
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L148-L150

---
### Proof of Concept
0. Users A and B each stake 100e18 YEET
    - Contract State:
        - `YEET.balance(StakeV2)`: 200e18
        - `totalSupply`: 200e18
        - Real rewards: 0

1. B starts unstaking 100e18 YEET
    - Contract State:
        - `YEET.balance(StakeV2)`: 200e18 (unchanged)
        - `totalSupply`: 100e18 (reduced by B's unstake)
        - Tokens in vesting: 100e18 (B's unstaking amount)

2. Manager Distributes "Rewards": 
    - `accumulatedDeptRewardsYeet()` returns: 200e18 - 100e18 = 100e18
    - These rewards (actually B's vesting tokens) are distributed
    - Contract State:
        - `YEET.balance(StakeV2)`: 100e18
        - `totalSupply`: 100e18
        - **Tokens distributed as "rewards": 100e18**

3. B finalizes unstake at vesting period ends and withdraws their 100e18 YEET
    - Final Contract State:
        - `YEET.balance(StakeV2)`: 0
        - `totalSupply`: 100e18 (A's stake)
        - **Result: A's stake becomes unbacked by tokens**

---

## <a name="h-01">[H-01]</a> Attacker can DoS `StakeV2`'s rewards distribution by repeatedly inflating Zapper's approval for whitelisted Kodiak Vault tokens

* **Severity**: High
* Source: [Attacker can DoS `StakeV2`'s rewards distribution by repeatedly inflating Zapper's approval for whitelisted Kodiak Vault tokens](https://reports.immunefi.com/yeet/41432-sc-high-attacker-can-dos-stakev2-s-rewards-distribution-by-repeatedly-inflating-zappers-approv)
---
### Brief/Intro
An attacker can **repeatedly inflate the Zapper's approval** for any **whitelisted Kodiak Vault tokens** that are **targeted for distribution as `StakeV2` rewards**. This leads to a **Denial-of-Service (DoS) on rewards distribution** due to an **overflow revert in `safeIncreaseAllowance()`**, without incurring any direct cost other than gas fees.

---
### Vulnerability Details
The **Zapper contract** **increases its allowance** for Kodiak Vault tokens based on **user-specified `amount0Max` and `amount1Max` values**. However, these amounts **are not necessarily fully utilized** when adding liquidity, causing **excess approvals to accumulate indefinitely**. 

Over time, this can **inflate the allowance to `uint256.MAX` (or a nearest value), leading to an overflow revert in operation that include calling `safeIncreaseAllowance()`**.
Note: The attack steps are described in the **Proof of Concept** section.

```solidity
    function _approveAndAddLiquidityToKodiakVault(
        ...
    ) internal returns (uint256, uint256, uint256) {
        --- SNIPPED ---
@>      token0.safeIncreaseAllowance(address(kodiakStakingRouter), stakingParams.amount0Max);
@>      token1.safeIncreaseAllowance(address(kodiakStakingRouter), stakingParams.amount1Max);
        // add liquidity using KodiakStakingRouter
        return kodiakStakingRouter.addLiquidity(
            IKodiakVaultV1(kodiakVault),
            stakingParams.amount0Max,
            stakingParams.amount1Max,
            stakingParams.amount0Min,
            stakingParams.amount1Min,
            stakingParams.amountSharesMin,
            stakingParams.receiver
        );
    }
``` 

```solidity
// SafeERC20.sol
function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
    uint256 oldAllowance = token.allowance(address(this), spender);
@>  forceApprove(token, spender, oldAllowance + value);
}
```

The actual amount of tokens used is computed within `IslandRouter._addLiquidity()`, where `amount0In` and `amount1In` are determined based on the minimum amount from `_computeMintAmounts()`.

```solidity
// KodiakIslandRouter: 0x679a7C63FC83b6A4D9C1F931891d705483d4791F (Berachain-Mainnet)
function _addLiquidity(
    ...
) internal returns (uint256 amount0, uint256 amount1, uint256 mintAmount) {
    IERC20 token0 = island.token0();
    IERC20 token1 = island.token1();
@>  (uint256 amount0In, uint256 amount1In, uint256 _mintAmount) = island.getMintAmounts(amount0Max, amount1Max);
    require(amount0In >= amount0Min && amount1In >= amount1Min && _mintAmount >= amountSharesMin, "below min amounts");

@>  if (amount0In > 0) token0.safeTransferFrom(msg.sender, address(this), amount0In);
@>  if (amount1In > 0) token1.safeTransferFrom(msg.sender, address(this), amount1In);

    return _deposit(island, amount0In, amount1In, _mintAmount, receiver);
}
```

```solidity
// YEET-WBERA KodiakIsland: 0xEc8BA456b4e009408d0776cdE8B91f8717D13Fa1 (Berachain-Mainnet)

function getMintAmounts(uint256 amount0Max, uint256 amount1Max) external view returns (uint256 amount0, uint256 amount1, uint256 mintAmount) {
    uint256 totalSupply = totalSupply();
    if (totalSupply > 0) {
@>      (amount0, amount1, mintAmount) = _computeMintAmounts(totalSupply, amount0Max, amount1Max);
    } else { //@note assume that it on-live and totalSupply > 0
        // ...
    }
}

function _computeMintAmounts(uint256 totalSupply, uint256 amount0Max, uint256 amount1Max) private view returns (uint256 amount0, uint256 amount1, uint256 mintAmount) {
    (uint256 amount0Current, uint256 amount1Current) = getUnderlyingBalances();

    --- SNIPPED ---
    } else {
        // only if both are non-zero
        uint256 amount0Mint = FullMath.mulDiv(amount0Max, totalSupply, amount0Current);
        uint256 amount1Mint = FullMath.mulDiv(amount1Max, totalSupply, amount1Current);
        require(amount0Mint > 0 && amount1Mint > 0, "mint 0");

@>      mintAmount = amount0Mint < amount1Mint ? amount0Mint : amount1Mint;
    }

    // compute amounts owed to contract
@>  amount0 = FullMath.mulDivRoundingUp(mintAmount, amount0Current, totalSupply);
@>  amount1 = FullMath.mulDivRoundingUp(mintAmount, amount1Current, totalSupply);
}
```
---
### Impact Details
- The `StakeV2` reward distribution suffers from a **Denial-of-Service (DoS) vulnerability**, preventing rewards from being distributed, which results in the **permanent freezing of unclaimed yield**.
- The **Zapper** cannot execute `_yeetIn` for certain tokens that have undergone **inflation in approval amounts**.

Although the **Kodiak Router** can be replaced with a new one, the attack can be **repeated** on the new router, as the logic still allows it.

Moreover, in the rare case that the **Kodiak Vault** settings in the **Zapper contract** become malicious, an attacker could potentially **pull any funds from the Zapper** (if funds are available).
---
### References
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L507-L508
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L153-L180
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L182-L201

---
### Proof of Concept
* Here is the runnable PoC: https://gist.github.com/merlinboii/90dfcadc9170a55a3e6b39555a4e0461 
Result Logs: 
```bash
[PASS] test_attack_inflateApproval_DoS() (gas: 5141513)
Logs:
  Inflated allowance: 115792089237316195423570985008687907853269984665640564039457534956561230671075
  Delta: 49051351898968860
```

* Below is the step-by-step conceptual PoC: This PoC uses YEET-WBERA KodiakIsland ([0xEc8BA456b4e009408d0776cdE8B91f8717D13Fa1](https://beratrail.io/address/0xEc8BA456b4e009408d0776cdE8B91f8717D13Fa1/contract/80094/code)) on Berachain Mainnet to demonstrate how a user can inflate Zapper‚Äôs approval allowance without spending full amounts.

0. **`StakeV2` Rewards System**  
   - The **LP rewards** for **YEET-WBERA Kodiak Island** consist of:  
     - `token0`: **YEET**  
     - `token1`: **WBERA**  
   - The `StakeV2` contract contains the functions:  
     - `executeRewardDistributionYeet()`, which distributes **YEET** rewards.  
     - `executeRewardDistribution()`, which distributes **BERA** rewards.  
   - These functions call `_yeetIn()` to **add liquidity** to the **YEET-WBERA Kodiak Vault** and **deposit LP rewards into Trifecta Vaults**.  

1. **Attacker Target: DoS the Reward Distribution and Feasibility**      
    - **Approach for DoS**: Inflate the Zapper's approval allowance for `YEET` or `WBERA` to `uint256(MAX)`, causing an overflow revert when `safeIncreaseAllowance()` is executed before liquidity is added.  
    ```solidity
        function _approveAndAddLiquidityToKodiakVault(
            ...
        ) internal returns (uint256, uint256, uint256) {
            --- SNIPPED ---
    @>      token0.safeIncreaseAllowance(address(kodiakStakingRouter), stakingParams.amount0Max);
    @>      token1.safeIncreaseAllowance(address(kodiakStakingRouter), stakingParams.amount1Max);
            // add liquidity using KodiakStakingRouter
            return kodiakStakingRouter.addLiquidity(
                IKodiakVaultV1(kodiakVault),
                stakingParams.amount0Max,
                stakingParams.amount1Max,
                stakingParams.amount0Min,
                stakingParams.amount1Min,
                stakingParams.amountSharesMin,
                stakingParams.receiver
            );
        }
    ```
    - **Approach for Attack Feasibility**: Target Zapper functions that **do not require transferring full `stakingParams.amount0Max` or `stakingParams.amount1Max` before executing `_yeetIn()`**:  
        - `zapInToken0()`: Transfers `stakingParams.amount0Max + swapData.inputAmount` and allows **arbitrary input for `stakingParams.amount1Max`**.  
        - `zapInToken1()`: Transfers `stakingParams.amount1Max + swapData.inputAmount` and allows **arbitrary input for `stakingParams.amount0Max`**.  
        - `zapIn()`: Transfers the `inputToken` amount and allows **arbitrary input for `stakingParams.amount0Max` and `stakingParams.amount1Max`**.  
        - Since the `addLiquidity()` process caps minting at the **minimum liquidity result** calculated from both `amount0Max` and `amount1Max`, the **arbitrary inputs will not affect the actual LP minting results**.

2. Attacker calls `Zapper.zapInToken0()`. The user **sets an artificially high approval of `stakingParams.amount1Max`** for Kodiak Vault tokens (`YEET` and `WBERA`): 
```solidity
Zapper.zapInToken0(
    swapData, // swap inputAmount: YEET (token0) for WBERA (token1), preparing WBERA for adding liquidity along with YEET from `stakingParams.amount0Max`
    KodiakVaultStakingParams({
        kodiakVault: address(YEET_BERA_KODIAK_ISLAND),
        amount0Max: 1e18, // 1 YEET
        amount1Max: 7719472615821079694904732333912527190217998977709370935963838933860875309329, // uint256(MAX) / 15 times 
        // ...
        receiver: address(user) // user got LP directly and not trigger to deposit them to vault
    }),
    vaultParams
)
```

3. The process triggers to **increase allowance** up to 
    - `amount0Max: 1e18`
    - `amount1Max: 7719472615821079694904732333912527190217998977709370935963838933860875309329`.
```solidity
    function _approveAndAddLiquidityToKodiakVault(
        address kodiakVault,
        IERC20 token0,
        IERC20 token1,
        IZapper.KodiakVaultStakingParams calldata stakingParams
    ) internal returns (uint256, uint256, uint256) {
        --- SNIPPED ---
@>      token0.safeIncreaseAllowance(address(kodiakStakingRouter), stakingParams.amount0Max);
@>      token1.safeIncreaseAllowance(address(kodiakStakingRouter), stakingParams.amount1Max);
        // add liquidity using KodiakStakingRouter
        return kodiakStakingRouter.addLiquidity(
            IKodiakVaultV1(kodiakVault),
            stakingParams.amount0Max,
            stakingParams.amount1Max,
            stakingParams.amount0Min,
            stakingParams.amount1Min,
            stakingParams.amountSharesMin,
            stakingParams.receiver
        );
    }
``` 

3. We can see the actual of `amount0In`, `amount1In` and `mintAmount` from that simulate block (`Block: 2275117`) by reading from `YEET-WBERA-KodiakIsland.getMintAmounts()`:  
```
[
  "999999999999999986", //amount0In
  "3461048089839568", //amount1In
  "43710258853688038" //mintAmount
]
```

3. As from the process of `IslandRouter._addLiquidity()`, it will only transfer `999999999999999986` YEET and `3461048089839568` WBERA to the router contract for further deposit operation (minting LP).
```solidity
function _addLiquidity(
    ...
) internal returns (uint256 amount0, uint256 amount1, uint256 mintAmount) {
    IERC20 token0 = island.token0();
    IERC20 token1 = island.token1();
    (uint256 amount0In, uint256 amount1In, uint256 _mintAmount) = island.getMintAmounts(amount0Max, amount1Max);
    require(amount0In >= amount0Min && amount1In >= amount1Min && _mintAmount >= amountSharesMin, "below min amounts");

@>  if (amount0In > 0) token0.safeTransferFrom(msg.sender, address(this), amount0In);
@>  if (amount1In > 0) token1.safeTransferFrom(msg.sender, address(this), amount1In);

    return _deposit(island, amount0In, amount1In, _mintAmount, receiver);
}
```

4. **The allowance of `Zapper` for `KodiakStakingRouter` will not reset to 0 and remains**: 
  - YEET: 1e18 - 999999999999999986
  - WBERA: 7719472615821079694904732333912527190217998977709370935963838933860875309329 - 3461048089839568 = **~uint256(MAX) / 15 times**

5. The attacker can **repeat the process** until the allowance reaches `uint256.MAX` (or the nearest value), causing an **overflow revert** whenever the target token executes `safeIncreaseAllowance()` on the Zapper for a Kodiak router.

6. The attacker **receives LP tokens** along with unused `YEET` and `WBERA` from providing liquidity. **This means the attacker only incurs gas costs for execution.**  

7. When `StakeV2.executeRewardDistributionYeet()` or `StakeV2.executeRewardDistribution()` is executed, and the `oldAllowance` (inflated to ~`uint256.MAX`) plus `value` (`stakingParams.amountXMax`) **exceeds `uint256.MAX`**, it **triggers an overflow revert**:
```solidity
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
@>      forceApprove(token, spender, oldAllowance + value);
    }
```
---
### Final Stage: Denial-of-Service (DoS) to StakeV2 Reward Distribution process via Zapper Approval Inflation
The attacker **inflates the Zapper‚Äôs approval for `YEET` and `WBERA` on the `KodiakStakingRouter`**, **causing a DoS condition by making further approvals impossible**.

---

## <a name="h-02">[H-02]</a> Permanent freezing of yield due to incorrect reward handling in `StakeV2` claim functions

* **Severity**: High
* Source: [Permanent freezing of yield due to incorrect reward handling in `StakeV2` claim functions](https://reports.immunefi.com/yeet/41280-sc-high-permanent-freezing-of-yield-due-to-incorrect-reward-handling-in-stakev2-claim-function)
---

### Brief/Intro
Users claiming rewards through `StakeV2`'s claim functions: `claimRewardsInNative()` , `claimRewardsInToken0()`, `claimRewardsInToken1()` and `claimRewardsInToken()`, which are designed to handle reward claims in a single output token (either native, token0, token1, or a whitelisted token) can **permanently lose access to a portion of their rewards**. 

This occurs because the `Zapper` contract incorrectly sends any remaining token debt to `StakeV2` instead of the user who initiated the claim. Since `StakeV2` has no mechanism to recover or redistribute these tokens, the lost funds become permanently inaccessible to the user.

---
### Vulnerability Details
This vulnerability stems from **a flawed interaction between StakeV2‚Äôs claim functions and Zapper‚Äôs token return logic** when **users opt to swap their rewards into a single output token**: 

1. In `claimRewardsInNative() -> zapOutNative() -> _swapToWBERA()`: The remaining `token0Debt` and `token1Debt` are transferred to `_msgSender()`, which is now refer to `msg.sender` (`StakeV2`)
```solidity
function _swapToWBERA(
...
) internal returns (uint256 wBeraDebt) {
    if (address(token0) == address(wbera)) {
        wBeraDebt += token0Debt;
        token0Debt = 0;
    } else {
        wBeraDebt += _verifyTokenAndSwap(swapData0, address(token0), address(wbera), address(this));
        token0Debt -= swapData0.inputAmount;
    }

    if (address(token1) == address(wbera)) {
        wBeraDebt += token1Debt;
        token1Debt = 0;
    } else {
        wBeraDebt += _verifyTokenAndSwap(swapData1, address(token1), address(wbera), address(this));
        token1Debt -= swapData1.inputAmount;
    }
    // log yeetBalance
@>  _clearUserDebt(token0, token1, token0Debt, token1Debt, _msgSender());  
}
```

2. In `claimRewardsInToken0() -> zapOutToToken0()`: The remaining `token1Debt` is transferred to `_msgSender()`, which is now refer to `msg.sender` (`StakeV2`)
```solidity
function zapOutToToken0(
    ...
) public nonReentrant onlyWhitelistedKodiakVaults(unstakeParams.kodiakVault) returns (uint256 totalToken0Out) {
    --- SNIPPED ---
    token1Debt -= swapData.inputAmount;
    token0Debt += _verifyTokenAndSwap(swapData, address(token1), address(token0), address(this));
    _sendERC20Token(token0, receiver, token0Debt);
@>  _sendERC20Token(token1, _msgSender(), token1Debt);
    return (token0Debt);
}
```

3. In `claimRewardsInToken1() -> zapOutToToken1()`: The remaining `token0Debt` is transferred to `_msgSender()`, which is now refer to `msg.sender` (`StakeV2`)
```solidity
function zapOutToToken1(
    ...
) public nonReentrant onlyWhitelistedKodiakVaults(unstakeParams.kodiakVault) returns (uint256 totalToken1Out) {
    --- SNIPPED ---
    token0Debt -= swapData.inputAmount;
    token1Debt += _verifyTokenAndSwap(swapData, address(token0), address(token1), address(this));
@>  _sendERC20Token(token0, _msgSender(), token0Debt);
    _sendERC20Token(token1, receiver, token1Debt);
    return (token1Debt);
}
```

4. In `claimRewardsInToken() -> zapOut()`: The remaining `token0Debt` and `token1Debt` are transferred to `_msgSender()`, which is now refer to `msg.sender` (`StakeV2`)
```solidity
function zapOut(    
    ...
)
public
override
nonReentrant
onlyWhitelistedKodiakVaults(unstakeParams.kodiakVault)
returns (uint256 totalAmountOut)
{
    --- SNIPPED ---
    } else {
        // sent directly to receiver. What is receiver is zapper?
        totalAmountOut += _verifyTokenAndSwap(swap0, address(token0), outputToken, receiver);
        token0Debt -= swap0.inputAmount;
        totalAmountOut += _verifyTokenAndSwap(swap1, address(token1), outputToken, receiver);
        token1Debt -= swap1.inputAmount;
    }
@>  _clearUserDebt(token0, token1, token0Debt, token1Debt, _msgSender());
}
```

5. **In the `StakeV2`, there is no logic to handle the remaining token debt, whether after calling the Zapper function or an external function to handle this case.**

---
### Impact Details
Users lose access to their full earned rewards when claiming through `StakeV2` if they opt to receive a single output token (`Native, Token0, Token1, or a whitelisted token`) and do not perfectly specify the swap amount.
1.	If the user specifies `swapDataX.inputAmount < tokenXDebt` (the amount received after removing liquidity from Kodiak), the excess `tokenXDebt - swapDataX.inputAmount` is sent to `StakeV2` instead of the user and users permanently lose access to a portion of their earned rewards.
2.	It is **not feasible for users to perfectly predict `swapDataX.inputAmount`** as the remove liquidity function only guarantees slippage protection but cannot provide an exact output amount so **users cannot reliably specify an inputAmount that exactly matches `tokenXDebt`, making some amount of loss inevitable**.

```solidity
function _approveAndUnstakeFromKodiakVault(
    IZapper.KodiakVaultUnstakingParams calldata unstakeParams,
    uint256 islandTokenDebt
) internal returns (IERC20, IERC20, uint256, uint256) {
    --- SNIPPED ---
    (uint256 _amount0, uint256 _amount1,) = kodiakStakingRouter.removeLiquidity(
        IKodiakVaultV1(unstakeParams.kodiakVault),
        islandTokenDebt,
@>      unstakeParams.amount0Min,
@>      unstakeParams.amount1Min,
        unstakeParams.receiver
    );

    // require(islandTokenDebt == _liqBurned, "Invalid island token burn amount");
    return (_token0, _token1, _amount0, _amount1);
}
```

---
### References
- The claim reward functions of `StakeV2` : https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L327-L394
- The related Zapper's functions: https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L249-L353
- The related vulnerable lines: 
  - https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L262
  - https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L284
  - https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L310
  - https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L622
  - https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/contracts/Zapper.sol#L352

---
### Proof of Concept
Use the case `claimRewardsInToken0()` for example, here's how users can permanently lose their remaining debt equivalent to a portion of their rewards:

#### Prerequisites
- User has staked YEET in `StakeV2` and earned `500` trifecta vault shares as rewards, which can be redeemed into **YEET-WBERA LP tokens**
- Current YEET-WBERA Kodiak Island ratio: `1 YEET = 0.00167 BERA` (`token0 = YEET`, `token1 = WBERA`)
- Expected rewards after removing LP: `2,000 YEET + 3.34 WBERA`
- **What the user can estimate (but not precisely predict at execution time)**:
  - The **amount of vault shares** available for redemption (`calculateRewardsEarned()`).
  - The **amount of `YEET` and `WBERA` received from LP removal** (from current of Kodiak Island vault state).

#### Vulnerability Flow
1. The user intends to claim all rewards as `YEET` by swapping `WBERA` to `YEET`.
```solidity
StakeV2.claimRewardsInToken0(
    500 shares,  // Amount of vault shares to redeem
    IZapper.SingleTokenSwap({
        inputAmount: 3.30 * 1e18,  // User estimates to swap all output WBERA to YEET
        outputQuote: 2,000 * 1e18,  // Quote amount for YEET
        outputMin: 1,995 * 1e18,  // Slippage for YEET
        executor: address(executor),
        path: swapPathData
    }),
    IZapper.KodiakVaultUnstakingParams({
        kodiakVault: address(YEET_BERA_KODIAK_ISLAND),
        amount0Min: 1,995 * 1e18,  // Slippage for YEET
        amount1Min: 3.30 * 1e18,  // Slippage for WBERA
        receiver: address(zapper),  // Opt in swap process
    }),
    redeemParams // the amount to claim will be prepared in `StakeV2._verifyAndPrepareClaim()`
);
```

2. The actual amount from Kodiak remove liquidity: 
  - YEET received: 2,010 YEET
  - WBERA received: 3.34 WBERA
  - These amounts include `LP fees` and potential price impact variations.

3. The swap processes a fixed `inputAmount` for swapping `WBERA` to `YEET` via `OBRouter` and the given `executor`:
  - Swap `inputAmount`: 3.30 WBERA 
  - Swap `output`: 1,995 YEET
  - Balance Zapper after swap:
    - YEET: 2,010 (from LP) + 1,995 (swap output) = 4,005 YEET
    - WBERA: 3.34 (from LP) - 3.30 (swapped) = 0.04 WBERA

4. Zapper processes to transfer remaining Debt: 
  - YEET: 4,005 YEET -> sent to user (`receiver`)
  - WBERA: 0.04 WBERA -> sent to `StakeV2` (`_msgSender()`)

--- 
### Final State: User's loss 0.04 WBERA and permanently locked in the `StakeV2`
**Additional Note**: If the lost amount is in `YEET`, it will be incorrectly redistributed as extra rewards via: `StakeV2.executeRewardDistributionYeet()` so this creates unfair rewards distribution, benefiting other claimers.

---

## <a name="l-01">[L-01]</a> Full or Large WBERA reward collects can be blocked by small amounts

* **Severity**: Low
* Source: [Full or Large WBERA reward collects can be blocked by small amounts](https://reports.immunefi.com/yeet/41886-sc-low-full-or-large-wbera-reward-collects-can-be-blocked-by-small-amounts)
---

### Brief/Intro
**The `depositWBERA` function in `StakeV2` contract is vulnerable to front-running attacks that can prevent the protocol from collecting full or large amounts of surplus `WBERA`**. While this doesn't affect the main `BERA` reward distribution, it can temporarily disrupt the protocol's ability to handle surplus rewards.

---
### Vulnerability Details
The `depositWBERA` function in the `StakeV2` contract allows converting `WBERA` held by the contract into `BERA` for reward distribution:

```solidity
function depositReward() public payable {
    require(msg.value > 0, "Must send value");
@>  accumulatedRewards += msg.value;
    emit RewardDeposited(msg.sender, msg.value);
}
--- SNIPPED ---
function depositWBERA(uint256 amount) external {
@>  wbera.withdraw(amount);
    this.depositReward{
            value: amount
        }();
}
```

However, this function is **vulnerable to a frontrunning attack**, where an attacker can **deposit a dust amount (e.g., 1 wei) right before a legitimate large deposit transaction**. This results in only the dust amount being processed, while the full deposit attempt fails and reverts due to insufficient available `WBERA`.

This issue should not be confused with normal transaction races, where multiple legitimate transactions may compete to deposit the full amount. In those cases, the total intended amount is still successfully converted into `BERA` over multiple transactions, even if one of them fails.

Instead, this vulnerability **specifically allows an attacker to block full `WBERA` deposits** by ensuring only an insignificant amount gets collected.

---
### Impact Details
* **Griefing** (e.g. no profit motive for an attacker, but damage to the
users or the protocol)
* An attacker can **indefinitely frontrun** these events to disrupt protocol operations.
* The impact is more significant if the function is called together with reward distribution, especially when a manager is smart contract and its reward distribution handler does: `{depositWBERA(wbera.balanceOf(stakeV2)); executeRewardDistribution(...);}`}.

Although, the issue can be classified as `Griefing (Medium)`, its impact is more aligned with `Contract fails to deliver promised returns, but doesn't lose value (Low)`, due to the following limitations: 
* Only affects surplus `WBERA` (donations are also affected, but this is not the primary reward mechanism, as rewards are mainly distributed in `BERA`)
* Main reward distribution uses `BERA` and remains unaffected (only surplus from distribution events is impacted)
* Can be worked around using partial deposits

---
### Recommendation
1. Allows to input `amount` as `type(uint256).max` to trigger full balance deposit: 
```diff
function depositWBERA(uint256 amount) external {
+   uint256 withdrawAmount = amount;
+   if (amount == type(uint256).max) {
+       withdrawAmount = wbera.balanceOf(address(this));
+   }
-    wbera.withdraw(amount);
+    wbera.withdraw(withdrawAmount);
    this.depositReward{
-           value: amount
+           value: withdrawAmount
        }();
}
```

2. Handle `WBERA` within the `executeRewardDistribution` so this eliminates the need for separate `depositWBERA` calls

---
### References
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L138-L143

https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L190

https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L182-L201

---
### Proof of Concept
#### Runnable PoC
* Put the following test into `test/StakeV2.test.sol:StakeV2_ExecuteRewardsDistrubution`
```solidity
    function test_audit_handleExcessToken1DepositWBERA() public {
        address add = makeAddr("Koala");
        stakeV2.addManager(add);
        vm.deal(add, 1000 ether);
        vm.startPrank(add);
        // Add excess wbera to staking contract to simulate debt
        wbera.deposit{
                value: 100 ether
            }();
        wbera.transfer(address(stakeV2), 100 ether);
        vm.stopPrank();
        
        uint256 amountToDeposit = wbera.balanceOf(address(stakeV2));
        
        // frontrun deposit 1 wei
        address alice = makeAddr("alice");
        vm.prank(alice);
        stakeV2.depositWBERA(1);
        
        // tx got executed after
        vm.expectRevert();
        stakeV2.depositWBERA(amountToDeposit);
    }
}
```
* Run: `forge test --match-test test_audit_handleExcessToken1DepositWBERA -vvv`

#### Conceptual PoC
0. Initial stats:
    - `StakeV2` holds 1e18 `WBERA` (surplus)
    - `accumulatedRewards`: 20e18 `BERA`
2. Manager initiates **full** collection: `depositWBERA(1e18)`
3. Attacker see the transaction then frontrun with 1 wei dust deposit: `depositWBERA(1)`
    - The balance of `WBERA` becomes `1e18 - 1`
    - `accumulatedRewards`: 20e18 + 1 `BERA`

4. When the manger's tx got executed, it will revert due to insufficient funds
    - actual balance: `1e18 - 1` **less than** expected withdraw: `1e18`

5. Attacker can also disrupt and prevent LARGE deposits  as well, by calculating: 
    - `required deposit` = `WBERA.balanceOf(stakeV2)` - `upcoming withdrawal` + 1   
    - **Griefing becomes attractive as long as `upcoming withdrawal` >> `required deposit`**

---

## <a name="l-02">[L-02]</a> Incorrect `maxWithdraw()` returns lead to user failed withdrawals of returned maximum amount

* **Severity**: Low
* Source: [Incorrect `maxWithdraw()` returns lead to user failed withdrawals of returned maximum amount](https://reports.immunefi.com/yeet/42539-sc-low-incorrect-maxwithdraw-returns-lead-to-user-failed-withdrawals-of-returned-maximum-amoun)
---

### Brief/Intro
The `MoneyBrinter.maxWithdraw()` function returns an overestimated value that doesn't account for withdrawal fees, causing withdrawals at the reported maximum to always revert due to insufficient shares balance to burn.

---
### Vulnerability Details
The ERC4626 implementation's `maxWithdraw` calculates withdrawable assets as:
```solidity
function maxWithdraw(address owner) public view virtual returns (uint256) {
    return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);
}
```

However, the `previewWithdraw()` implementation adds a fee:

```solidity
function previewWithdraw(uint256 assets) public view override returns (uint256) {
    uint256 fee = _feeOnRaw(assets, exitFeeBasisPoints);
    return super.previewWithdraw(assets + fee);
}
```

This creates a mathematical inconsistency where the `maxWithdraw()` is returned the assets from the shares `balance of owner`, but the `previewWithdraw()` returns the assets from the shares `balance of owner + fee`.

Moreover, this is not compile with EIP-4626 as according to [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626#maxwithdraw) specifications, `maxWithdraw` MUST:
1. **Return the maximum amount of assets that could be transferred from owner through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).**
2. MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.
3. MUST NOT revert.

---
### Impact Details
Low (Contract fails to deliver promised returns, but doesn't lose value)

While no funds are directly at risk, this issue:
1. Cause failed transactions and wasted gas when users attempt to withdraw their reported maximum
2. Breaks core EIP-4626 functionality and compliance

---
### Proof of Concept

Initial state:
-   Assume a user has 100 shares in the vault
-   Assume the exchange rate is 1:1 (1 share = 1 asset)
-   Assume exitFeeBasisPoints = 100 (1%)

1. User queries their maximum withdrawable amount
```solidity
uint256 maxAssets = vault.maxWithdraw(user);
// maxAssets = _convertToAssets(balanceOf(user): 100 shares) = 100 assets
```

2. User attempts to withdraw this maximum amount
```solidity
function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {
    uint256 maxAssets = maxWithdraw(owner);
// maxAssets = 100 assets
vault.withdraw(100 assets, user, user);
```

3. The `withdraw()` function will revert because:
```solidity
// First check PASSES because assets == maxAssets
if (assets > maxAssets) { 
    revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);
}

// Calculate shares needed
uint256 shares = previewWithdraw(assets); // Calculate shares for 100 assets

// Inside previewWithdraw():
uint256 fee = _feeOnRaw(100, 100); // 100 * 100 / 10000 = 1 (with ceiling rounding)
return super.previewWithdraw(100 + 1); // Calculate shares for 101 assets
// shares = 101

// Try to burn 101 shares, but user only has 100
// REVERTS here
@> _withdraw(_msgSender(), receiver, owner, assets: 100, shares: 101);
```

The transaction reverts because the user needs 101 shares to withdraw 100 assets (query from `maxWithdraw()`), but they only have 100 shares.

---

## <a name="i-01">[I-01]</a> Previous owner still hold manager role after ownership transfer

* **Severity**: Insight
* Source: [Previous owner still hold manager role after ownership transfer](https://reports.immunefi.com/yeet/41659-sc-insight-previous-owner-still-hold-manager-role-after-ownership-transfer)
---

### Brief/Intro
The `Manager` contract allows previous owners to retain their manager role even after ownership transfer. This could lead to unauthorized access to manager's privileged functions: `executeRewardDistributionYeet()` and `executeRewardDistribution()`. If proper role cleanup is not performed manually, potentially compromising the protocol's access control system.

---
### Vulnerability Details
Manager roles handling in the `Manager` contract are not automatically revoked during ownership transfer:

1. In the constructor, both owner and manager get manager roles:
```solidity
constructor(address _owner, address _manager) Ownable(_owner) {
    managers[_owner] = true;
    managers[_manager] = true;
}
```

2. When ownership is transferred using Ownable's `transferOwnership`, the previous owner's manager status remains as there is no override logic to cleanup of manager roles:

3. The `removeManager` function exists but must be called manually:
```solidity
function removeManager(address _manager) external override onlyOwner {
    require(managers[_manager], "Manager does not exist");
    require(_manager != address(0), "Invalid address");
    managers[_manager] = false; 
}
```

---
### Impact Details
This could be considered a `Security best practices`assuming that all setup roles are trusted, including the previous owner, who was trusted before the transfer.

However, if the previous owner was compromised and their address has not yet been removed from the manager role, it creates an opportunity for an attacker to frontrun the `removeManager()` and operate crucial functions.

---
### References
https://github.com/immunefi-team/audit-comp-yeet/blob/main/src/StakeV2.sol#L35-L59

---
### Proof of Concept
1. During deployment, Trusted-Owner-A (EOA) is used as the deployer of the contract and holds both owner and manager roles
2. After setup is complete, ownership is transferred from Trusted-Owner-A to Trusted-Owner-B (The Multisig)
3. Trusted-Owner-A retains their manager role
4. Over time, if Trusted-Owner-A's account becomes compromised or experiences key leakage, attacker can still race to call `executeRewardDistributionYeet()` and `executeRewardDistribution()` to distribute and redirect reward distributions to their own addresses (by setting `vaultParams.receiver != StakeV2`)

---